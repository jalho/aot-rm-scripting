{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\fswiss\fprq2\fcharset0 Arial;}{\f2\fmodern\fprq1\fcharset0 Courier New;}{\f3\froman\fprq2\fcharset2 Symbol;}{\f4\fswiss\fcharset0 Arial;}}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}}
\viewkind4\uc1\pard\qc\b\f0\fs32 AI Help File Document\par
\i Age of Mythology\i0\'99\par
\pard\b0\fs24\par
\b\'a9 2002, Microsoft Corporation. All rights reserved.\b0\par
\b\par
Important:\b0  \i Age of Mythology\i0  allows you to create your own AI scripts. You may share these custom AI scripts for the purposes of gameplay, but you may not sell or make other commercial uses of the custom AI scripts. Microsoft\'ae reserves all other rights to the editors and files.\par
\par
\pard\keepn\s3\sb240\sa60\b\f1\fs26 AI Script Help File Document\par
\pard\lang1024\b0\f2\fs16\par
\f0\fs24 The AoM AI scripting system is a very powerful system that allows the user to craft the AI using the same language as the folks at Ensemble Studios.  While this is a useful enduser feature, it is officially unsupported.\par
\par
The high level overview for creating your own random map AI scripts is as follows:\par
\pard\fi-360\li720\tx720\lang1033\f3\'b7\tab\f0 Write your random map script.\par
\pard\fi-360\li720\f3\'b7\tab\f0 Add an XML file into your AI directory following the format of default.xml, defaultboom.xml, or defaultrush.xml.\par
\f3\'b7\tab\f0 See your AI appear in the list of dropdown choices when you run the game.\par
\f3\'b7\tab\f0 Debug it using the ingame debugging facilities:\par
\pard\fi-360\li1440\tx1440\f2 o\tab\f0 Add \ldblquote aiDebug\rdblquote  to your user.cfg file in the startup directory.\par
\pard\fi-360\li1440\f2 o\tab\f0 When the game is running, hit ALT+SHIFT+D to bring up the debugger.\par
\pard For a scenario, the steps are largely the same, except that you need to associate the AI script filename with the right player via the scenario editor (Player Data dialog).\par
\lang1024\par
A list of the type enumerations and function calls that can be made from the AI scripts is included at the end of this document.\par
\par
AoM includes a source debugger for your XS scripts.  This is accessed by including a line with \ldblquote aiDebug\rdblquote  on it in the user.cfg in the Startup directory of your AoM installation.  If you do not have a user.cfg file, create one with any text editor.  Once this is in your user.cfg, hitting ALT+SHIFT+D will bring up the debugger.  Different XS runtimes (AI for each player, triggers, etc.) will be available for debugging.  The debugger is an unsupported feature.\par
\par
You can also use the \ldblquote aiEcho(\'85)\rdblquote  syscall (see the syscall reference at the end of this document) to print out debugging strings, etc. during the execution of your AI.  To see these, you must put a \ldblquote showAIEchoes\rdblquote  line in your user.cfg.\par
\pard\keepn\s3\sb240\sa60\lang1033\b\f1\fs26\page Sample AOM Scripts\par
\pard\lang1024\b0\f0\fs24 The following script code is a sample script from one of the AoM single-player scenarios.  As such, it does not demonstrate everything that is possible with the AI scripting system, but it does provide a working example.  More examples (including all of the script code for the Random Map AI for AoM) can be found in the \ldblquote AI\rdblquote  subdirectory of your AoM installation.\par
\par
\f1\par
\f2\fs16 I. Sample Script File\par
\f1\fs20\par
\f2\fs16 //==============================================================================\par
// Scn08p2: AI Scenario Script for scenario 8 player 2\par
//==============================================================================\par
/*\par
   Overview:\par
   The human player rescues Ajax from the Trojan army, then joins forces at the \par
   allied TC.  His goal is to build up and take out the red town to the north, without \par
   the availability of siege units.\par
\par
   The CP sends one trivial attack early, which dies hopelessly to the HP's huge \par
   army left over from the start.  Several of the following attack rules are currently \par
   implemented by triggers which attempt to build military buildings near\par
   the HP's town.\par
   \par
   The CP attacks down any one of three channels, with the west channel reserved for \par
   higher difficulty levels.\par
\par
   No attempt is made to train units out of the forward buildings, even if the \par
   feeble attempt to build succeeds.  If the forward building concept stays in, we should\par
   add rules to make a local army out of each building and use them for extra attacks.   \par
\par
   CP starts as age 2 with Animal Magnet (not used) and Pestilence.\par
   Age 3: Aphrodite: Curse\par
   Age 4: Hephaestus: Plenty\par
\par
*/\par
//==============================================================================\par
\par
\par
include\b  \b0 "scn lib.xs";\b\par
\b0\par
// Globals\par
int         lastAttackPlanID = -1; // Updated with plan ID as each attack is launched\par
int         defendPlan = -1;\par
\par
int         reservePlan = -1; // Extra defend plan, higher priority, for final resistance\par
int         startTime = -1; \tab // Updated with start time when cinematic is done.  \par
                              // In seconds.\par
               \par
int         age3Time = 1500;\tab // Time (in seconds) to go to age 3\par
int         age4Time = 10000;\par
int         siegeMaintainPlan = -1;\par
int         mythMaintainPlan = -1;\par
int         hopliteMaintainPlan = -1;\par
int         toxotesMaintainPlan = -1;\par
int         hippikonMaintainPlan = -1;\par
int         villagerMaintainPlan = -1;\par
\par
int         routeWestPass = -1;\par
int         routeNorthPass = -1;\par
int         routeEastPass = -1;\par
\par
// Initial settings are for the easiest difficulty level, others are set in main().\par
int         nextAttackTime = 480000;     // 8 minutes\par
float       attackSize = 4.0; \par
float       maxAttackSize = 9.0;\par
float       attackSizeMultiplier = 1.2; \par
int         attackInterval = 300000;      // 5 minutes\par
float       reserveSize = 15.0;           // Army to keep in reserve\par
int         attackCount = 0;\par
int         trainDelay = 30;\par
int         cavTrainDelay = 30;\par
int         archerTrainDelay = 15;\par
int         infantryTrainDelay = 20;\par
\par
int builderQty = 1;     // For forward building\par
int defendQty = 0;      // For escort group\par
\par
// Cinematic block markers\par
const string cbVillagerGather = "1872";\par
const string cbSiegeGather = "1873";\par
const string cbArcherGather = "1878";\par
const string cbCavalryGather = "1874";\par
const string cbInfantryGather = "1875";\par
const string cbP2TC = "1876";\par
const string cbGateEast = "1826";\par
const string cbGateWest = "1827";\par
const string cbWestPass1 = "1833";\par
const string cbWestPass2 = "1832";\par
const string cbNorthWestPlateau = "1834";\par
const string cbNorthEastPlateau = "1835";\par
const string cbP1Gold = "1831";\par
const string cbP1Granary = "1830";\par
const string cbSouthField = "1877";\par
const string cbEastPass1 = "1828";\par
const string cbEastPass2 = "1829";\par
const string cbP1TC = "1836";\par
const string cbNorthPass = "2272";\par
const string cbAttack2Stable = "1882";\par
const string cbAttack2Army = "1883";\par
const string cbAttack5Tower = "1880";\par
const string cbAttack3Army = "1881";\par
\par
// Econ \par
int   maxVills = 20;        // Will scale with difficulty\par
int   maxFishBoats = 0;    // Including one to scout\par
float goldPercent = 0.25;\par
float woodPercent = 0.15;\par
float foodPercent = 0.60;\par
int   gathererTypeID = -1;\par
int   fishGatherer = -1;\par
int   mainBase = -1;\par
float mainRadius = 100.0;\par
\par
\par
\page // *****************************************************************************\par
//\par
// Building plan support for forward building\par
//\par
// *****************************************************************************\par
int buildPlan = -1;\par
int buildDefend = -1;\par
// Set the following four vars, then just enable testBuildPlan.\par
int buildUnit = cUnitTypeTower;\par
vector buildVec = cInvalidVector;\par
vector startPoint = cInvalidVector;\par
\par
rule buildPlanRule\par
   inactive\par
\{\par
\par
   buildPlan = aiPlanCreate("Build Plan", cPlanBuild);\par
   if(buildPlan >= 0)\par
   \{\par
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, buildUnit);\par
      aiPlanSetDesiredPriority(buildPlan, 40);\par
      aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, buildVec);\par
      aiPlanSetInitialPosition(buildPlan, startPoint);\par
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 12);\par
      aiPlanAddUnitType(buildPlan,\par
                        kbTechTreeGetUnitIDTypeByFunctionIndex(cUnitFunctionBuilder, 0),\par
                        1, builderQty, builderQty);\par
      aiPlanSetEscrowID(buildPlan, cRootEscrowID);\par
      aiPlanSetInitialPosition(buildPlan, buildVec);\par
      aiPlanSetActive(buildPlan);\par
   \}\par
\par
   buildDefend =aiPlanCreate("Build Defend Plan", cPlanDefend);\par
   if (buildDefend >= 0)\par
   \{\par
      aiPlanAddUnitType(buildDefend, cUnitTypeMilitary, 0, defendQty, defendQty);\par
      aiPlanSetDesiredPriority(buildDefend, 60); // Above other defend plans\par
      aiPlanSetVariableVector(buildDefend, cDefendPlanDefendPoint, 0, buildVec);\par
      aiPlanSetVariableFloat(buildDefend, cDefendPlanEngageRange, 0, 15);\par
      aiPlanSetVariableBool(buildDefend, cDefendPlanPatrol, 0, false);\par
      aiPlanSetVariableFloat(buildDefend, cDefendPlanGatherDistance, 0, 8.0);\par
      aiPlanSetInitialPosition(buildDefend, kbGetBlockPosition(cbInfantryGather));\par
      aiPlanSetUnitStance(buildDefend, cUnitStanceDefensive);\par
\par
      aiPlanSetVariableInt(buildDefend, cDefendPlanRefreshFrequency, 0, 5);\par
      aiPlanSetNumberVariableValues(buildDefend, cDefendPlanAttackTypeID, 2, true);\par
      aiPlanSetVariableInt(buildDefend, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);\par
      aiPlanSetVariableInt(buildDefend, cDefendPlanAttackTypeID, 1, cUnitTypeBuilding);\par
      \par
      aiPlanSetActive(buildDefend); \par
      aiEcho("Creating defend plan");\par
   \}\par
   xsEnableRule("endBuildDefend");\par
   xsDisableSelf();\par
\}\par
\par
rule endBuildDefend\par
   inactive\par
   minInterval 7\par
\{\par
   aiEcho("Build Plan state is "+aiPlanGetState(buildPlan));\par
   if (aiPlanGetState(buildPlan) == -1)\par
   \{\par
      aiPlanDestroy(buildDefend);\par
      aiEcho("Destroying build defend plan");\par
      xsDisableSelf();\par
   \}\par
\}\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
//                                FUNCTIONS\par
//\par
// *****************************************************************************\par
\b0\par
\par
void age2EventHandler(int bogus=-1)\par
\{\par
   xsEnableRule("usePestilence");\par
   xsEnableRule("goToAge3");\par
   xsEnableRule("getAge2UnitUpgrades");\par
   xsEnableRule("getAge2ArmoryUpgrades");\par
\}\par
\par
\par
\par
void age3EventHandler(int bogus=-1)\par
\{\par
   xsEnableRule("useCurse");\par
   siegeMaintainPlan = maintainUnit(cUnitTypePetrobolos, reserveSize/8,\par
                                    kbGetBlockPosition(cbSiegeGather), 60);\par
   xsEnableRule("getAge3UnitUpgrades");\par
   xsEnableRule("getAge3ArmoryUpgrades");\par
\}\par
\par
\par
void age4EventHandler(int bogus=-1)\par
\{\par
   xsEnableRule("usePlenty");\par
   xsEnableRule("getAge4UnitUpgrades");\par
   xsEnableRule("getAge4ArmoryUpgrades");\par
   xsEnableRule("usePlenty");\par
\}\par
\par
\par
// Called by a trigger, to let AI know that the game has started\par
void wakeup(int parm=-1)\par
\{\par
   startTime = xsGetTime()/1000;\par
   aiEcho("Wakeup running at "+startTime);\par
\par
   if (kbGetAge() >= cAge2)\par
      age2EventHandler(0);\par
   if (kbGetAge() >= cAge3)\par
      age3EventHandler(0);\par
   if (kbGetAge() >= cAge4)\par
      age4EventHandler(0);\par
\par
   xsEnableRule("attackGenerator");\par
   xsEnableRule("scout");\par
   hippikonMaintainPlan = maintainUnit(cUnitTypeHippikon, reserveSize/3,\par
                                       kbGetBlockPosition(cbCavalryGather),\par
                                       cavTrainDelay);\par
\par
   toxotesMaintainPlan = maintainUnit(cUnitTypeToxotes, reserveSize/3,\par
                                      kbGetBlockPosition(cbArcherGather),\par
                                      archerTrainDelay);\par
\par
   hopliteMaintainPlan = maintainUnit(cUnitTypeHoplite, reserveSize/3,\par
                                      kbGetBlockPosition(cbInfantryGather),\par
                                      infantryTrainDelay);\par
\par
   // Init low-priority defend plan to manage spare units\par
   defendPlan =aiPlanCreate("Defend Plan", cPlanDefend);\par
   if (defendPlan >= 0)\par
   \{\par
      // All unassigned mil units\par
      aiPlanAddUnitType(defendPlan, cUnitTypeMilitary, 0, 200, 200);\par
      \par
\page       // Way low, below scouting and attack\par
      aiPlanSetDesiredPriority(defendPlan, 10);      \par
      aiPlanSetVariableVector(defendPlan, cDefendPlanDefendPoint, 0,\par
                              kbGetBlockPosition(cbInfantryGather));\par
      aiPlanSetVariableFloat(defendPlan, cDefendPlanEngageRange, 0, 30);\par
\par
      aiPlanSetVariableFloat(defendPlan, cDefendPlanGatherDistance, 0, 15.0);\par
      aiPlanSetInitialPosition(defendPlan, kbGetBlockPosition(cbInfantryGather));\par
      aiPlanSetUnitStance(defendPlan, cUnitStanceDefensive);\par
\par
      aiPlanSetNumberVariableValues(defendPlan, cDefendPlanPatrolWaypoint, 3, true);\par
      aiPlanSetVariableVector(defendPlan, cDefendPlanPatrolWaypoint, 0,\par
                              kbGetBlockPosition(cbGateEast));\par
      aiPlanSetVariableVector(defendPlan, cDefendPlanPatrolWaypoint, 1,\par
                              kbGetBlockPosition(cbEastPass1));\par
      aiPlanSetVariableVector(defendPlan, cDefendPlanPatrolWaypoint, 2,\par
                              kbGetBlockPosition(cbGateWest));\par
      aiPlanSetVariableBool(defendPlan, cDefendPlanPatrol, 0, true);\par
\par
      aiPlanSetVariableInt(defendPlan, cDefendPlanRefreshFrequency, 0, 5);\par
      aiPlanSetNumberVariableValues(defendPlan, cDefendPlanAttackTypeID, 2, true);\par
      aiPlanSetVariableInt(defendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);\par
      aiPlanSetVariableInt(defendPlan, cDefendPlanAttackTypeID, 1, cUnitTypeBuilding);\par
      \par
      aiPlanSetActive(defendPlan); \par
      aiEcho("Creating defend plan");\par
   \}\par
\par
   // Higher-priority defend plan to reserve units for final push\par
   reservePlan =aiPlanCreate("Reserve Plan", cPlanDefend);\par
   if (reservePlan >= 0)\par
   \{\par
      // All unassigned mil units\par
      aiPlanAddUnitType(reservePlan, cUnitTypeMilitary, 0, reserveSize/2, reserveSize/2);   \par
      \par
      // Higher than other defend plans\par
      aiPlanSetDesiredPriority(reservePlan, 30);                       \par
      aiPlanSetVariableVector(reservePlan, cDefendPlanDefendPoint, 0,\par
\pard\fi720\li2160 kbGetBlockPosition(cbP2TC));\par
\pard       aiPlanSetVariableFloat(reservePlan, cDefendPlanEngageRange, 0, 15);\par
\par
      aiPlanSetVariableFloat(reservePlan, cDefendPlanGatherDistance, 0, 15.0);\par
      aiPlanSetInitialPosition(reservePlan, kbGetBlockPosition(cbInfantryGather));\par
      aiPlanSetUnitStance(reservePlan, cUnitStanceDefensive);\par
\par
      aiPlanSetVariableBool(reservePlan, cDefendPlanPatrol, 0, false);\par
\par
      aiPlanSetVariableInt(reservePlan, cDefendPlanRefreshFrequency, 0, 5);\par
      aiPlanSetNumberVariableValues(reservePlan, cDefendPlanAttackTypeID, 2, true);\par
      aiPlanSetVariableInt(reservePlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);\par
      aiPlanSetVariableInt(reservePlan, cDefendPlanAttackTypeID, 1, cUnitTypeBuilding);\par
      \par
      aiPlanSetActive(reservePlan); \par
      aiEcho("Creating defend plan");\par
   \}\par
\par
   // Create villager maintain plan\par
   createSimpleMaintainPlan(gathererTypeID, maxVills, true, mainBase);\par
\}\par
\par
void initMainBase()\par
\{\par
   // Nuke bases, add one base to rule them all\par
   kbBaseDestroyAll(cMyID);\par
\par
   mainBase = kbBaseCreate(cMyID, "Base "+kbBaseGetNextID(), \par
\pard\fi720\li2160 kbGetBlockPosition(cbP2TC), mainRadius);\par
\pard    if (mainBase < 0)\par
      aiEcho("***** Main base creation failed. *****");\par
\par
\pard\li300 vector baseFront=xsVectorNormalize(kbGetMapCenter()-kbGetBlockPosition(cbP2TC));     // Set front\par
\pard\fi300 kbBaseSetFrontVector(cMyID, mainBase, baseFront);                 \par
\pard\li300 kbBaseSetMaximumResourceDistance(cMyID, mainBase, mainRadius+20.0);                      // Gather up to 20m beyond base perimeter\par
\pard    kbBaseSetMain(cMyID, mainBase, true);     // Make this the main base\par
\par
   // Add the buildings\par
   int buildingQuery = -1;\par
   int count = 0;\par
   buildingQuery = kbUnitQueryCreate("Building Query");     // All buildings in the base\par
   configQuery(buildingQuery, cUnitTypeBuilding, -1, cUnitStateAliveOrBuilding, \par
\pard\fi720\li720 cMyID, kbGetBlockPosition(cbP2TC), false, mainRadius);\par
\pard    kbUnitQueryResetResults(buildingQuery);\par
   count = kbUnitQueryExecute(buildingQuery);\par
\par
   int i = 0;\par
   int buildingID = -1;\par
   for (i=0; < count)\par
   \{\par
      buildingID = kbUnitQueryGetResult(buildingQuery, i);\par
      // Add it to the base\par
      kbBaseAddUnit( cMyID, mainBase, buildingID );\par
   \}\par
\}\par
\par
\par
void initEcon()\par
\{\par
   aiSetAutoGatherEscrowID(cRootEscrowID);\par
   aiSetAutoFarmEscrowID(cRootEscrowID);\par
   gathererTypeID = kbTechTreeGetUnitIDTypeByFunctionIndex(cUnitFunctionGatherer,0);\par
  \par
   int herdPlanID=aiPlanCreate("GatherHerdable Plan", cPlanHerd);\par
   if (herdPlanID >= 0)\par
   \{\par
      aiPlanAddUnitType(herdPlanID, cUnitTypeHerdable, 0, 100, 100);\par
      aiPlanSetVariableInt(herdPlanID, cHerdPlanBuildingTypeID, \par
\pard\fi720\li2160 0, cUnitTypeSettlementLevel1);\par
\pard       aiPlanSetActive(herdPlanID);\par
   \}\par
\par
   aiSetResourceGathererPercentageWeight(cRGPScript, 1);\par
   aiSetResourceGathererPercentageWeight(cRGPCost, 0);\par
\par
   kbSetAICostWeight(cResourceFood, 1.0);\par
   kbSetAICostWeight(cResourceWood, 0.7);\par
   kbSetAICostWeight(cResourceGold, 0.8);\par
   kbSetAICostWeight(cResourceFavor, 7.0);\par
\par
   aiSetResourceGathererPercentage(cResourceFood, foodPercent, false, cRGPScript);\par
   aiSetResourceGathererPercentage(cResourceWood, woodPercent, false, cRGPScript);\par
   aiSetResourceGathererPercentage(cResourceGold, goldPercent, false, cRGPScript);\par
   aiSetResourceGathererPercentage(cResourceFavor, 0.0, false, cRGPScript);\par
   aiNormalizeResourceGathererPercentages(cRGPScript);\par
\par
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, 1, 50, 1.0, mainBase);\par
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, 1, 50, 1.0, mainBase);\par
   aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, 1, 50, 1.0, mainBase);\par
   aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, 1, 50, 1.0, mainBase);\par
\}\par
\par
void main()\par
\{\par
   aiEcho("Starting Scn08p2.xs");\par
   kbSetTownLocation(kbGetBlockPosition(cbP2TC));\par
   aiRandSetSeed();\par
\par
   //Calculate some areas.\par
   kbAreaCalculate(1200.0);\par
   aiSetAttackResponseDistance(10.0);\par
\par
   kbEscrowSetPercentage( cEconomyEscrowID, cAllResources, 0.0);\par
   kbEscrowSetPercentage( cMilitaryEscrowID, cAllResources, 0.0);\par
   kbEscrowAllocateCurrentResources();\par
\par
\par
   initMainBase();    // Destroy all auto-bases, make one manual base for everything\par
   initEcon();\par
\par
   aiSetAgeEventHandler(cAge2, "age2EventHandler");\par
   aiSetAgeEventHandler(cAge3, "age3EventHandler");\par
   aiSetAgeEventHandler(cAge4, "age4EventHandler");\par
\par
   // Create attack routes\par
   routeWestPass = attackRoute("West Pass",cbGateWest, cbWestPass1, cbWestPass2);\par
   routeEastPass = attackRoute("East Pass",cbGateEast, cbEastPass1, cbEastPass2);\par
   routeNorthPass = attackRoute("North Pass", cbGateWest, cbNorthPass, cbP1TC);\par
\par
   switch(aiGetWorldDifficulty())\par
   \{     // ignores 0 (easiest), uses initial values in that case.\par
   case 1:     // medium\par
      \{\par
         nextAttackTime = 300000;      // 5 minutes\par
         attackSize = 6.0; \par
         maxAttackSize = 12.0;\par
         attackSizeMultiplier = 1.2; \par
         attackInterval = 240000;      // 4 minutes   \par
         reserveSize = 20;\par
         age3Time = 1200;               // Time (in seconds) to go to age 3\par
         age4Time = 1800; \par
         defendQty = 2;\par
         builderQty = 2;\par
         trainDelay = 25;\par
         break;\par
      \}\par
   case 2:     // difficult/hard\par
      \{\par
         nextAttackTime = 180000;      // 3 minutes\par
         attackSize = 8.0; \par
         maxAttackSize = 30.0;\par
         attackSizeMultiplier = 1.2; \par
         attackInterval = 180000;      // 3 minutes    \par
         reserveSize = 35;\par
         age3Time = 900;               // Time (in seconds) to go to age 3\par
         age4Time = 1500;                   \par
         defendQty = 3;\par
         builderQty = 5;\par
         trainDelay = 15;\par
         break;\par
      \}\par
   case 3:     // hardest/nightmare\par
      \{\par
         nextAttackTime = 30000;      // 30 sec\par
         attackSize = 10.0; \par
         maxAttackSize = 50.0;\par
         attackSizeMultiplier = 1.3; \par
         attackInterval = 108000;      // 3 minutes     \par
         reserveSize = 60;\par
         age3Time = 500;               // Time (in seconds) to go to age 3\par
         age4Time = 900;                   \par
         defendQty = 6;\par
         builderQty = 10;\par
         trainDelay = 10;\par
         break;\par
      \}\par
   \}\par
\par
   cavTrainDelay = trainDelay;\par
   archerTrainDelay = trainDelay/2;\par
   infantryTrainDelay = (2*trainDelay)/3;\par
\}\par
\par
\par
void siegeUnitAttack(vector location=vector(-1,-1,-1), int qty=1)\par
\{\par
   static int attackQuery = -1;\par
   static int attackQuery2 = -1;\par
   int   attackID=aiPlanCreate("Mixed Unit Attack at "+timeString(),cPlanAttack);\par
   if (attackID < 0)\par
   \{\par
      return;\par
   \}\par
\par
   if (aiPlanSetVariableInt(attackID, cAttackPlanPlayerID, 0, 1) == false)\par
   \{\par
      return;\par
   \}\par
\par
   if (aiPlanSetNumberVariableValues(attackID, cAttackPlanTargetTypeID, 3, true) \par
\pard\fi720 == false)\par
\pard       return;\par
\par
   aiPlanSetVariableInt(attackID, cAttackPlanTargetTypeID, 0, cUnitTypeUnit);\par
   aiPlanSetVariableInt(attackID, cAttackPlanTargetTypeID, 1, cUnitTypeBuilding);\par
   aiPlanSetVariableInt(attackID, cAttackPlanTargetTypeID, 2, cUnitTypeAbstractWall);\par
\par
   // Set up the attack queries with the appropriate vectors\par
   if (aiPlanSetNumberVariableValues(attackID, cAttackPlanQueryID, 2, true) == false)\par
   \{\par
      return;\par
   \}\par
   if (attackQuery < 0)\par
   \{\par
      attackQuery = kbUnitQueryCreate("Attack Query");\par
      configQueryRelation(attackQuery, cUnitTypeUnit, -1, cUnitStateAlive,\par
                          cPlayerRelationEnemy, location, false, 50);\par
   \}\par
   else\par
   \{\par
      kbUnitQuerySetPosition(attackQuery, location);\par
   \}\par
\par
   if (attackQuery2 < 0)\par
   \{\par
      attackQuery2 = kbUnitQueryCreate("Attack Query #2");\par
      configQuery(attackQuery2, cUnitTypeBuilding, -1, cUnitStateAliveOrBuilding,\par
\pard\fi720\li720    cPlayerRelationEnemy, location, false, 50);\par
\pard    \}\par
   else\par
   \{\par
      kbUnitQuerySetPosition(attackQuery2, location);\par
   \}\par
   aiPlanSetVariableInt(attackID, cAttackPlanQueryID, 0, attackQuery);\par
   aiPlanSetVariableInt(attackID, cAttackPlanQueryID, 1, attackQuery2);\par
\par
\par
   if (aiRandInt(2) == 0)\par
      aiPlanSetVariableInt(attackID, cAttackPlanAttackRouteID, 0, routeNorthPass);\par
   else\par
      aiPlanSetVariableInt(attackID, cAttackPlanAttackRouteID, 0, routeEastPass);\par
\par
\par
   aiPlanSetVariableVector(attackID, cAttackPlanGatherPoint, \par
\pard\fi720\li2160 0, kbGetBlockPosition(cbInfantryGather));\par
\pard    aiPlanSetVariableFloat(attackID, cAttackPlanGatherDistance, 0, 25.0);\par
\par
   aiPlanAddUnitType(attackID, cUnitTypeHoplite, 1, 3*qty/10, 3*qty/10);\par
   aiPlanAddUnitType(attackID, cUnitTypeToxotes, 1, 4*qty/10, 4*qty/10);\par
   aiPlanAddUnitType(attackID, cUnitTypeHippikon, 1, 3*qty/10, 3*qty/10);\par
   // Add siege if this is attack 4 or higher.\par
   if (attackCount > 4)\par
      aiPlanAddUnitType(attackID, cUnitTypePetrobolos, 1, (qty+5)/10, (qty+5)/10);\par
\par
   aiPlanSetInitialPosition(attackID, kbGetBlockPosition(cbInfantryGather));\par
   aiPlanSetRequiresAllNeedUnits(attackID, false);\par
   aiPlanSetActive(attackID);\par
   aiEcho("Activating attack plan "+attackID);\par
   if (lastAttackPlanID >= 0)\par
      aiPlanDestroy(lastAttackPlanID);   // free up last set of units?\par
   lastAttackPlanID = attackID; // update the global var\par
\}\par
\par
\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// RULES\par
//\par
// *****************************************************************************\par
\b0\par
\par
rule goToAge3\par
   inactive\par
   mininterval 20\par
\{\par
   if ( (xsGetTime()/1000) < age3Time )\par
      return;\par
   researchTech(cTechAge3Aphrodite);\par
   xsEnableRule("goToAge4");\par
   xsEnableRule("getAge3UnitUpgrades");\par
   xsEnableRule("getAge3ArmoryUpgrades");\par
   xsDisableSelf();\par
\}\par
\par
rule goToAge4\par
   inactive\par
   mininterval 20\par
\{\par
   return;  // disabled for now.\par
\par
   if ( (xsGetTime()/1000) < age4Time )\par
      return;\par
   researchTech(cTechAge4Hephaestus);\par
   xsEnableRule("getAge4UnitUpgrades");\par
   xsEnableRule("getAge4ArmoryUpgrades");\par
   xsDisableSelf();\par
\}\par
\par
\par
\par
rule getAge2UnitUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   if ( (xsGetTime()/1000) < (age3Time/3) )\par
      return;     \par
   researchTech(cTechMediumInfantry);\par
   researchTech(cTechMediumArchers);\par
//   researchTech(cTechMediumCavalry);\par
   xsDisableSelf();\par
\}\par
\par
rule getAge2ArmoryUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   if ( (xsGetTime()/1000) < (2*age3Time)/3 )\par
      return;     \par
   aiEcho("Getting age 2 armory upgrades");\par
   researchTech(cTechCopperWeapons);\par
   researchTech(cTechCopperMail);\par
   researchTech(cTechCopperShields);\par
   xsDisableSelf();\par
\}\par
\par
rule getAge3UnitUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   researchTech(cTechHeavyInfantry);\par
   researchTech(cTechHeavyArchers);\par
   researchTech(cTechHeavyCavalry);\par
   xsDisableSelf();\par
\}\par
\par
rule getAge3ArmoryUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   researchTech(cTechBronzeWeapons);\par
   researchTech(cTechBronzeMail);\par
   researchTech(cTechBronzeShields);\par
   xsDisableSelf();\par
\}\par
\par
rule getAge4UnitUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   researchTech(cTechChampionInfantry);\par
   researchTech(cTechChampionArchers);\par
   researchTech(cTechChampionCavalry);\par
   xsDisableSelf();\par
\}\par
\par
rule getAge4ArmoryUpgrades\par
   inactive\par
   minInterval 20\par
\{\par
   researchTech(cTechIronWeapons);\par
   researchTech(cTechIronMail);\par
   researchTech(cTechIronShields);\par
   xsDisableSelf();\par
\}\par
\par
rule scout\par
   inactive\par
\{\par
   // just set up an explore plan\par
   int exploreID = aiPlanCreate("Explore", cPlanExplore);\par
   if(exploreID >= 0)\par
   \{\par
      aiPlanSetVariableFloat( exploreID, cExplorePlanLOSMultiplier,  0, 4.0 );\par
      aiPlanAddUnitType(exploreID, cUnitTypeHippikon, 1, 1, 1);\par
      aiPlanSetInitialPosition( exploreID, kbGetBlockPosition(cbNorthWestPlateau));\par
      aiPlanSetActive(exploreID);\par
   \}\par
   xsDisableSelf();\par
\}\par
\par
rule attackGenerator\par
   minInterval 10\par
   inactive\par
\{\par
   static int buildingQuery = -1;\par
\par
    //aiEcho("attack check running, next time is "+nextAttackTime);\par
   if ( xsGetTime() < nextAttackTime )\par
      return;\par
\par
   if (buildingQuery < 0)\par
   \{\par
      buildingQuery = kbUnitQueryCreate("Building Query");\par
      configQuery(buildingQuery, cUnitTypeBuilding, -1, cUnitStateAliveOrBuilding, \par
\pard\fi720\li720    1, kbGetBlockPosition(cbAttack5Tower), false, 20);\par
\pard    \}\par
\par
\par
   attackCount = attackCount + 1;\par
\par
   // Add forward building coincident with some attacks\par
   if (attackCount == 3)   // Make tower\par
   \{\par
      buildUnit = cUnitTypeTower;\par
      buildVec = kbGetBlockPosition(cbAttack5Tower);    // Gold mine\par
      startPoint = kbGetBlockPosition(cbWestPass1);\par
      kbUnitQueryResetResults(buildingQuery);\par
      if (kbUnitQueryExecute(buildingQuery) == 0)\par
         xsEnableRule("buildPlanRule");\par
      else\par
         aiEcho("Skipping tower build because of enemy buildings.");\par
   \}\par
   if (attackCount == 5)   // Make stable\par
   \{\par
      buildUnit = cUnitTypeStable;\par
      buildVec = kbGetBlockPosition(cbEastPass2);\par
      startPoint = kbGetBlockPosition(cbEastPass1);\par
      kbUnitQuerySetPosition(buildingQuery, startPoint);\par
      kbUnitQueryResetResults(buildingQuery);\par
      if (kbUnitQueryExecute(buildingQuery) == 0)\par
         xsEnableRule("buildPlanRule");\par
      else\par
         aiEcho("Skipping stable build because of enemy buildings.");   \}\par
   if (attackCount == 7)   // Make fortress\par
   \{\par
      buildUnit = cUnitTypeFortress;\par
      buildVec = kbGetBlockPosition(cbNorthEastPlateau);   // Elevated area north of town\par
      startPoint = kbGetBlockPosition(cbWestPass1);\par
      kbUnitQuerySetPosition(buildingQuery, startPoint);\par
      kbUnitQueryResetResults(buildingQuery);\par
      if (kbUnitQueryExecute(buildingQuery) == 0)\par
         xsEnableRule("buildPlanRule");\par
      else\par
         aiEcho("Skipping fortress build because of enemy buildings.");   \}\par
   if (aiRandInt(3) > 0)\par
   \{\par
      aiEcho("Normal attack");\par
      siegeUnitAttack(kbGetBlockPosition(cbP1TC), attackSize);\par
   \}\par
   else\par
   \{\par
      // 1 in 3 chance of aiming for green TC\par
      siegeUnitAttack(kbGetBlockPosition("2259"), attackSize); \par
      aiEcho("Deep attack");\par
   \}\par
   nextAttackTime = xsGetTime() + attackInterval;\par
   attackSize = attackSize * attackSizeMultiplier;\par
   if (attackSize > maxAttackSize)\par
      attackSize = maxAttackSize;\par
   aiEcho("Next attack size will be "+attackSize+".");\par
\}\par
\par
\par
\par
rule useCurse \par
   minInterval 5\par
   inactive\par
\{\par
\par
   // look for a group of 6 enemy military units, at my TC location or at my main \par
   // army's location\par
   int targetUnit = -1;\par
\par
   \par
   static int tempQuery = -1;\par
   if (tempQuery < 0)\par
   \{  // Doesn't exist, set it up\par
      tempQuery = kbUnitQueryCreate("useCurseHome");\par
      if ( configQuery(tempQuery, cUnitTypeUnit, -1, cUnitStateAlive, \par
\pard\fi720\li1440 1, kbGetBlockPosition(cbP2TC), true, 50) == false)\par
\pard          return;\par
   \}\par
   kbUnitQueryResetResults(tempQuery);\par
   int targetCount = kbUnitQueryExecute(tempQuery);  \par
\par
   if ( targetCount < 6 )\par
   \{\par
      vector pVec = aiPlanGetLocation(lastAttackPlanID);\par
      if (xsVectorGetX(pVec)>=0)\par
      \{\par
         static int tempQuery2 = -1;\par
         if (tempQuery2 < 0)\par
         \{  // Doesn't exist, set it up\par
            tempQuery2 = kbUnitQueryCreate("useCurseArmy");\par
            if ( configQuery(tempQuery2, cUnitTypeUnit, -1, cUnitStateAlive, \par
\pard\fi720\li2160 1, pVec, true, 50) == false)\par
\pard                return;\par
         \}\par
         else // Because pVec changes as army moves\par
            kbUnitQuerySetPosition(tempQuery2, pVec); \par
         kbUnitQueryResetResults(tempQuery2);\par
         targetCount = kbUnitQueryExecute(tempQuery2);  \par
         if (targetCount < 6)\par
            return;\par
         else// grab middle unit\par
            targetUnit = kbUnitQueryGetResult(tempQuery2, targetCount/2);  \par
      \}\par
      else\par
         return;\par
   \} \par
   else\par
      targetUnit = kbUnitQueryGetResult(tempQuery, targetCount/2);  // grab middle unit\par
\par
   aiEcho("Using Curse on unit "+targetUnit+" at "+kbUnitGetPosition(targetUnit));\par
   if ( aiCastGodPowerAtUnit(cTechCurse, targetUnit) == true)\par
      xsDisableSelf();\par
\}\par
\par
rule usePestilence\par
   minInterval 5\par
   inactive\par
\{\par
   // look for a group of 2 enemy buildings near my army.\par
\par
   if (lastAttackPlanID < 0)\par
      return;\par
\par
   vector pVec = aiPlanGetLocation(lastAttackPlanID);\par
   if (xsVectorGetX(pVec)<0)\par
      return;\par
\par
   static int tempQuery = -1;\par
   if (tempQuery < 0)\par
   \{  // Doesn't exist, set it up\par
      tempQuery = kbUnitQueryCreate("useBronze");\par
\par
      if ( configQuery(tempQuery, cUnitTypeLogicalTypeBuildingsThatTrainMilitary, \par
\pard\fi720\li1440 -1, cUnitStateAlive, 1, pVec, true, 50) == false)\par
\pard          return;\par
   \}\par
   else\par
      kbUnitQuerySetPosition(tempQuery, pVec); // Because pVec changes as army moves\par
   kbUnitQueryResetResults(tempQuery);\par
   int targetCount = kbUnitQueryExecute(tempQuery);  \par
\par
   if (targetCount < 2)\par
      return;\par
\par
   aiEcho("Using Pestilence at "+kbUnitGetPosition(kbUnitQueryGetResult(tempQuery, 0)));\par
   if ( aiCastGodPowerAtPosition(cTechPestilence,\par
\pard\fi720\li1440 kbUnitGetPosition(kbUnitQueryGetResult(tempQuery, 0))) == true)\par
\pard    \{\par
      aiEcho("Deactivating UsePestilence");\par
      xsDisableSelf();\par
   \}\par
\}\par
\par
\par
rule usePlenty\par
   minInterval 5\par
   inactive\par
\{\par
   vector aimHere = kbGetBlockPosition(cbP2TC);\par
   float dx = aiRandInt(40)-20.0;\par
   float dz = aiRandInt(40)-20.0;\par
   float newX = xsVectorGetX(kbGetBlockPosition(cbP2TC));\par
   float newZ = xsVectorGetZ(kbGetBlockPosition(cbP2TC));\par
   newX = newX + dx;\par
   newZ = newZ + dz;\par
\par
   aimHere = xsVectorSetX(aimHere, newX);    // TC vector +/-20 in x and z\par
   aimHere = xsVectorSetZ(aimHere, newZ);\par
\par
   if ( aiCastGodPowerAtPosition(cTechPlenty, aimHere) == true)\par
   \{\par
      aiEcho("Plenty worked at "+aimHere);\par
      xsDisableSelf();\par
   \}\par
   else\par
      aiEcho("Plenty failed at "+aimHere);\par
\}\par
\page\par
\b // *****************************************************************************\par
//\par
// scn lib.xs\par
//\par
// General library utilities for scenarios\par
// Leaner versions of RM utilities, without escrow IDs and other complications\par
//\par
// *****************************************************************************\par
\b0\par
\par
\par
\b //==============================================================================\par
// Failure\par
// To be called in the event of an error. Breaks the script, preserves\par
// the current call stack, etc.\par
//==============================================================================\par
\b0 void failure( string msg="" )\par
\{\par
\tab aiEcho("Failure: " + msg);\par
\}\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// configQuery\par
//\par
// Sets up all the non-default parameters so you can config a query on a single call.\par
// Query must be created prior to calling, and the results reset and the query executed\par
// after the call.\par
//\par
// ***************************************************************************** \par
\b0 bool  configQuery( int queryID = -1, int unitType = -1, int action = -1, int state = -1, int player = -1, vector center = vector(-1,-1,-1), bool sort = false, float radius = -1 )\par
\{\par
\par
   if ( queryID == -1)\par
   \{\par
      failure("Invalid query ID");\par
      return(false);\par
   \}\par
\par
   if (player != -1)\par
      kbUnitQuerySetPlayerID(queryID, player);\par
   \par
   if (unitType != -1)\par
      kbUnitQuerySetUnitType(queryID, unitType);\par
\par
   if (action != -1)\par
      kbUnitQuerySetActionType(queryID, action);\par
\par
   if (state != -1)\par
      kbUnitQuerySetState(queryID, state);\par
\par
   if (center != vector(-1,-1,-1))\par
   \{\par
      kbUnitQuerySetPosition(queryID, center);\par
      if (sort == true)\par
         kbUnitQuerySetAscendingSort(queryID, true);\par
      if (radius != -1)\par
         kbUnitQuerySetMaximumDistance(queryID, radius);\par
   \}\par
   return(true);\par
\}\par
\par
\b // *****************************************************************************\par
//\par
// configQueryRelation\par
//\par
// Sets up all the non-default parameters so you can config a query on a single call.\par
// Query must be created prior to calling, and the results reset and the query executed\par
// after the call.\par
// Unlike configQuery(), this uses the PLAYER RELATION rather than the player number\par
//\par
// ***************************************************************************** \par
\b0 bool  configQueryRelation( int queryID = -1, int unitType = -1, int action = -1, \par
\pard\fi720\li1440      int state = -1, int playerRelation = -1, \par
     vector center = vector(-1,-1,-1), bool sort = false, \par
     float radius = -1 )\par
\pard\{\par
\par
   if ( queryID == -1)\par
   \{\par
      failure("Invalid query ID");\par
      return(false);\par
   \}\par
\par
   if (playerRelation != -1)\par
      kbUnitQuerySetPlayerRelation(queryID, playerRelation);\par
   \par
   if (unitType != -1)\par
      kbUnitQuerySetUnitType(queryID, unitType);\par
\par
   if (action != -1)\par
      kbUnitQuerySetActionType(queryID, action);\par
\par
   if (state != -1)\par
      kbUnitQuerySetState(queryID, state);\par
\par
   if (center != vector(-1,-1,-1))\par
   \{\par
      kbUnitQuerySetPosition(queryID, center);\par
      if (sort == true)\par
         kbUnitQuerySetAscendingSort(queryID, true);\par
      if (radius != -1)\par
         kbUnitQuerySetMaximumDistance(queryID, radius);\par
   \}\par
   return(true);\par
\}\par
\par
\b //==============================================================================\par
// getUnit( int unitType, int action, vector center)\par
// \par
// Returns a unit of the specified type, doing the specified action.\par
// Defaults = any unit, any action.\par
// Searches units owned by this player only, can include buildings.\par
// If a location is specified, the nearest matching unit is returned.\par
//==============================================================================\par
\b0\par
int   getUnit( int unitType = -1, int action = -1, vector center = vector(-1,-1,-1) )\par
\{\par
\par
\pard\fi720 int   retVal = -1;\par
int   count = -1;\par
\pard\tab int   unitQueryID = kbUnitQueryCreate("unit");\par
\par
\tab // Define a query to get all matching units\par
\tab if (unitQueryID != -1)\par
\tab\{\par
\pard\fi720\li720 kbUnitQuerySetPlayerID(unitQueryID, cMyID);         // only my units\par
\pard       \tab\tab if (unitType != -1) // only if specified\par
   \tab\tab\tab kbUnitQuerySetUnitType(unitQueryID, unitType);   \par
\pard\fi720\li720 if (action != -1) // only if specified\par
\pard    \tab\tab\tab kbUnitQuerySetActionType(unitQueryID, action);   \par
      \tab\tab if (center != vector(-1,-1,-1))\par
\pard\fi720\li720\{\par
\pard        \tab\tab\tab kbUnitQuerySetPosition(unitQueryID, center);\par
         \tab\tab kbUnitQuerySetAscendingSort(unitQueryID, true);\par
\pard\fi720       \tab\}\par
\pard\tab\tab kbUnitQuerySetState(unitQueryID, cUnitStateAlive);\par
\tab\}\par
\tab else\par
   \tab\{\par
\pard\fi720\li720 failure("Couldn't create unit query.");\par
return(-1);\par
\pard\fi720\}\par
\pard\par
\tab kbUnitQueryResetResults(unitQueryID);\par
\tab count = kbUnitQueryExecute(unitQueryID);\par
\pard\fi720 // Add buildings in process\par
kbUnitQuerySetState(unitQueryID, cUnitStateBuilding);     \par
count = kbUnitQueryExecute(unitQueryID);\par
\pard\par
\pard\fi720 // Pick a unit and return its ID, or return -1.\par
if ( count > 0 )\par
if (center != vector(-1,-1,-1))\par
\pard\fi720\li720 retVal = kbUnitQueryGetResult(unitQueryID, 0);   // closest unit\par
\pard       \tab else // get the ID of a random unit\par
       \tab\tab retVal = kbUnitQueryGetResult(unitQueryID, aiRandInt(count));\tab\par
      \tab else\par
\pard\fi720\li720 retVal = -1;\par
\pard\par
\tab return(retVal);\par
\}\par
\par
\par
\b // *****************************************************************************\par
//\par
// trainUnit\par
//\par
// Train qty units of type unitID, optionally gathering at gatherPoint and \par
// training at a minimum of interval seconds apart.  Returns the planID, or -1 \par
// on failure.\par
// *****************************************************************************\par
\b0 int   trainUnit( int unitID=-1, int qty=1, vector gatherPoint=vector(-1,-1,-1), int interval=-1)\par
\{\par
\par
   if (unitID == -1)\par
      return(-1);\par
   if (qty < 1)\par
      return(-1);\par
   int planID = aiPlanCreate("Train "+qty+" "+kbGetProtoUnitName(unitID), cPlanTrain);\par
\tab if (planID >= 0)\par
\tab\{\par
\tab\tab aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, unitID);\par
\tab\tab aiPlanSetVariableInt(planID, cTrainPlanNumberToTrain, 0, qty);\par
      if (interval > 0)\par
   \tab\tab aiPlanSetVariableInt(planID, cTrainPlanFrequency, 0, interval);\par
      if (xsVectorGetX(gatherPoint) >= 0)\par
   \tab\tab aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, gatherPoint);\par
\tab\tab aiPlanSetActive(planID);\par
      return(planID);\par
\tab\}\par
   else\par
      return(-1);\par
\}\par
\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// maintainUnit\par
//\par
// Maintain a total of qty units of type unitID, optionally gathering at gatherPoint and \par
// training at a minimum of interval seconds apart.  Returns the planID, or -1 \par
// on failure.\par
// *****************************************************************************\par
\b0 int   maintainUnit( int unitID=-1, int qty=1, vector gatherPoint=vector(-1,-1,-1), int interval=-1)\par
\{\par
\par
   if (unitID == -1)\par
      return(-1);\par
   if (qty < 1)\par
      return(-1);\par
   int planID = aiPlanCreate("Maintain "+qty+" "+kbGetProtoUnitName(unitID), cPlanTrain);\par
\tab if (planID >= 0)\par
\tab\{\par
\tab\tab aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, unitID);\par
\tab\tab aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, qty);\par
      if (interval > 0)\par
   \tab\tab aiPlanSetVariableInt(planID, cTrainPlanFrequency, 0, interval);\par
      if (xsVectorGetX(gatherPoint) >= 0)\par
   \tab\tab aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, gatherPoint);\par
\tab\tab aiPlanSetActive(planID);\par
      return(planID);\par
\tab\}\par
   else\par
      return(-1);\par
\}\par
\par
\b // *****************************************************************************\par
//\par
// researchTech\par
// \par
// Creates a research plan to research the tech at an appropriate building\par
//\par
// *****************************************************************************\par
\b0 int   researchTech(int techID=-1)\par
\{\par
\tab int planID = aiPlanCreate("Research "+kbGetTechName(techID), cPlanProgression);\par
\tab if(planID < 0)\par
\tab\tab return(-1);\par
\par
\tab aiPlanSetVariableInt(planID, cProgressionPlanGoalTechID, 0, techID);\par
\tab aiPlanSetActive(planID);\par
   return(planID);\par
\}\par
\par
\par
\par
\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// attackRoute()\par
//\par
// Makes an attack route from a series of block names.  Must have 2-5 block names.\par
//\par
// *****************************************************************************\par
\b0 int   attackRoute(string name="default attack route", string block1="", string block2="",\par
\pard\fi720\li720    string block3="", string block4="", string block5="")\par
\pard\{\par
   string end="";\par
   int numPoints=0;\par
\par
   \par
   // Start at block 5, find the last one\par
   if (block5 != "")\par
   \{\par
      numPoints=5;\par
      end=block5;\par
   \}\par
   \par
   if ( (block4 != "") && (numPoints == 0) )\par
   \{\par
      numPoints=4;\par
      end=block4;\par
   \}\par
  \par
   if ( (block3 != "") && (numPoints == 0) )\par
   \{\par
      numPoints=3;\par
      end=block3;\par
   \}\par
\par
   if ( (block2 != "") && (numPoints == 0) )\par
   \{\par
      numPoints=2;\par
      end=block2;\par
   \}\par
   \par
   if ( (block1 != "") && (numPoints == 0) )\par
   \{\par
      numPoints=1;\par
      end=block1;\par
   \}\par
\par
   if (numPoints < 2)\par
      return(-1);\par
\par
   int pathID = kbPathCreate(name+" path");\par
   if (pathID < 0)\par
      return(-1);\par
\par
   if (numPoints > 2)\par
       kbPathAddWaypoint(pathID, kbGetBlockPosition(block2));\par
   if (numPoints > 3)\par
       kbPathAddWaypoint(pathID, kbGetBlockPosition(block3));\par
   if (numPoints > 4)\par
       kbPathAddWaypoint(pathID, kbGetBlockPosition(block4));\par
\par
\par
   int attackRouteID = kbCreateAttackRouteWithPath(name, kbGetBlockPosition(block1),\par
\pard\fi720\li4320 kbGetBlockPosition(end));\par
\pard    if (attackRouteID < 0)\par
      return(-1);\par
   if (numPoints > 2)\par
   kbAttackRouteAddPath(attackRouteID, pathID);\par
\par
   return(attackRouteID);\par
\}\par
\par
\par
\b // *****************************************************************************\par
//\par
// int getUnassignedUnitCount(vector center, float radius, int player, int unitType)\par
//\par
// Counts the number of player's units of type unitType that don't belong to \par
// a plan.  Count is limited to a distance of radius around point center.\par
//\par
// Generally used to count newly spawned units in order to set appropriate want/max\par
// levels for an attack plan.\par
// *****************************************************************************\b0\par
\par
int getUnassignedUnitCount(vector center=vector(-1.0, -1.0, -1.0), float radius=25.0, \par
\pard\fi720\li1440     int player=2, int unitType=cUnitTypeUnit)\par
\pard\{\par
   // Number of unassigned units found by traversing the query results\par
   int unassigned=0;       \par
\par
   // Query to find the units of unitType within radius of center.\par
   int query=-1;           \par
\par
   // Number of units found by the query.\par
   int count=-1;           \par
   int i=-1;\par
\par
   query = kbUnitQueryCreate("Unassigned units");\par
   if (query < 0)\par
      return(-1);\par
\par
   configQuery(query, unitType, -1, cUnitStateAlive, player, center, true, radius);\par
   kbUnitQueryResetResults(query);\par
   count = kbUnitQueryExecute(query);\par
\par
   for (i=0; <count)\par
   \{\par
      // if not a member of a plan...\par
      if (kbUnitGetPlanID(kbUnitQueryGetResult(query,i)) == -1)      \par
         unassigned = unassigned + 1;\par
   \}\par
   return(unassigned);\par
\}\par
\par
\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// string timeString(bool trimmed=true)\par
// \par
// Returns the current time in h:mm:ss format.  If trimmed is true, it suppresses\par
// leading spaces or zeros.  If false, string is always 7 characters.  \par
// Not responible for games over 10 hours.  ;-)\par
//\par
// *****************************************************************************\par
\b0 string timeString(bool trimmed=true)\par
\{\par
   int hour = 0;\par
   int min = 0;\par
   int sec = 0;\par
   int time = 0;\par
   string retval = "";\par
\par
   time = xsGetTime()/1000;   // Seconds\par
   hour = time/3600;\par
   time = time - (hour*3600);\par
   min = time/60;\par
   time = time -(min*60);\par
   sec = time;\par
\par
   if (trimmed == true)\par
   \{\par
      // start with h:\par
      if (hour > 0)           \{\par
         retval = hour+":";\par
         if (min >= 10)\par
            retval = retval+min+":";\par
         else\par
            retval = retval+0+min+":";\par
         if (sec >=10)\par
            retval = retval+sec;\par
         else\par
            retval = retval+0+sec;\par
      \}\par
      else\par
      \{  // start with min\par
         retval = min+":";\par
         if (sec >=10)\par
            retval = retval+sec;\par
         else\par
            retval = retval+0+sec;\par
      \}\par
   \}\par
   else  // non-trimmed\par
   \{\par
      retval = hour+":";\par
     if (min >= 10)\par
         retval = retval+min+":";\par
      else\par
         retval = retval+0+min+":";\par
      if (sec >=10)\par
         retval = retval+sec;\par
      else\par
         retval = retval+0+sec;\par
   \}\par
   return(retval);\par
\}\par
\par
\par
\par
/*\par
\b // *****************************************************************************\par
//\par
// build(int BuildingID, int areaID) \par
//\par
// *****************************************************************************\par
\b0\par
int build(int building=-1, int escrow=0, int areaID=-1)\par
\{\par
   int plan=aiPlanCreate("Build "+kbGetProtoUnitName(building), cPlanProgression);\par
   if (plan < 0)\par
      return(-1);\par
\par
   //Set it for the building that we get our unit from.\par
   aiPlanSetVariableInt(plan, cProgressionPlanGoalUnitID, 0, building);\par
   //Build it in our town.\par
   aiPlanSetVariableInt(plan, cProgressionPlanBuildAreaID, 0, areaID);\par
   //Go.\par
   aiPlanSetActive(plan);\par
   return(plan);\par
\}\par
*/\par
\par
\par
\par
\par
\b // *****************************************************************************\par
//\par
// echoQuery(int queryID)\par
//\par
// aiEchos the list of items in the query result space, with ID numbers and unit types.\par
//\par
// *****************************************************************************\par
\b0 void  echoQuery(int queryID = -1)\par
\{\par
   if (queryID < 0)\par
   \{\par
      aiEcho("Invalid query");\par
      return;\par
   \}\par
\par
   int i = 0;\par
   int id = 0;\par
   for (i=0; < kbUnitQueryNumberResults(queryID))\par
   \{\par
      id = kbUnitQueryGetResult(queryID, i);\par
      aiEcho("    "+id+" ("+kbGetProtoUnitName(kbGetUnitBaseTypeID(id))+")");\par
   \}\par
\par
\}\par
\par
\par
\par
\b //==============================================================================\par
//createSimpleMaintainPlan:  DCP\par
//==============================================================================\par
\b0 bool createSimpleMaintainPlan(int puid=-1, int number=1, bool economy=true, \par
\pard\fi720\li2160 int baseID=-1)\par
\pard\{\par
   //Create a the plan name.\par
   string planName="Military";\par
   if (economy == true)\par
      planName="Economy";\par
   // e.g. "Economy maintain 17 villager "\par
   planName=planName+" maintain "+number+" "+kbGetProtoUnitName(puid)+" ";\par
   int planID=aiPlanCreate(planName, cPlanTrain);\par
   if (planID < 0)\par
      return(false);\par
\par
   //Economy or Military.\par
   if (economy == true)\par
      aiPlanSetEconomy(planID, true);\par
   else\par
      aiPlanSetMilitary(planID, true);\par
   //Unit type.\par
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);\par
   //Number.\par
   aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, number);\par
\par
   //If we have a base ID, use it.\par
   if (baseID >= 0)\par
   \{\par
      aiPlanSetBaseID(planID, baseID);\par
      if  (economy == false)\par
         aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0,\par
\pard\fi720\li2160    kbBaseGetMilitaryGatherPoint(cMyID, baseID));\par
\pard    \}\par
\par
   aiPlanSetActive(planID);\par
\par
   //Done.\par
   return(true);\par
\}\par
\pard\keepn\s3\sb240\sa60\lang1033\b\f1\fs26\page List of AOM type enumerations and function calls\par
\pard\b0\f0\fs24\par
These are provided as a reference.  All of the const variable definitions are provided by the game and automatically included in your script (see the RM AI scripts in the AI directory for a working example).  There are some game-dependent items, such as cNumberPlayers, that will change based on how many players are in the game, etc.\par
\par
\lang1024\f2\fs16\par
//Player/Game:\par
const vector cInvalidVector=vector(-1.0, -1.0, -1.0);\par
const vector cOriginVector=vector(0.0, 0.0, 0.0);\par
const int cNumberPlayers=13;\par
const string cFilename="YourAIFilenameHere";\par
const int cMyID=12;\par
const string cMyName="RandomCPNameHere";\par
const int cMyCulture=2;\par
const int cMyCiv=7;\par
const string cRandomMapName="RandomMapNameHere";\par
\par
//Unit Stances:\par
const int cUnitStanceAggressive=0;\par
const int cUnitStanceDefensive=1;\par
const int cUnitStancePassive=2;\par
\par
//Victory Condition/Game Mode Types:\par
const int cGameModeSupremacy=0;\par
const int cGameModeConquest=1;\par
const int cGameModeLightning=2;\par
const int cGameModeDeathmatch=3;\par
\par
//Difficulty Levels:\par
const int cDifficultyEasy=0;\par
const int cDifficultyModerate=1;\par
const int cDifficultyHard=2;\par
const int cDifficultyNightmare=3;\par
\par
//Age Constants:\par
const int cAge1=0;\par
const int cAge2=1;\par
const int cAge3=2;\par
const int cAge4=3;\par
\par
//Player Relation Constants:\par
const int cPlayerRelationAny=-1;\par
const int cPlayerRelationSelf=0;\par
const int cPlayerRelationEnemy=2;\par
const int cPlayerRelationAlly=1;\par
\par
//Resource Gatherer Preferences:\par
const int cRGPScript=0;\par
const int cRGPCost=1;\par
const int cRGPActual=2;\par
\par
//Resource Subtypes:\par
const int cAIResourceSubTypeEasy=0;\par
const int cAIResourceSubTypeHunt=1;\par
const int cAIResourceSubTypeHuntAggressive=2;\par
const int cAIResourceSubTypeFarm=3;\par
const int cAIResourceSubTypeFish=4;\par
const int cAIResourceSubTypeTrade=5;\par
\par
//Escrow IDs:\par
const int cRootEscrowID=0;\par
const int cEconomyEscrowID=1;\par
const int cMilitaryEscrowID=2;\par
\par
//Plan Types:\par
const int cPlanMove=0;\par
const int cPlanAttack=1;\par
const int cPlanBuild=2;\par
const int cPlanTrain=3;\par
const int cPlanResearch=4;\par
const int cPlanWork=5;\par
const int cPlanGather=6;\par
const int cPlanExplore=7;\par
const int cPlanData=8;\par
const int cPlanProgression=9;\par
const int cPlanBuildWall=10;\par
const int cPlanFarm=11;\par
const int cPlanHunt=12;\par
const int cPlanHuntAggressive=13;\par
const int cPlanFish=14;\par
const int cPlanHerd=15;\par
const int cPlanEmpower=16;\par
const int cPlanTransport=17;\par
const int cPlanDropoffResource=18;\par
const int cPlanGatherRelic=19;\par
const int cPlanAttackStrategy=20;\par
const int cPlanGodPower=21;\par
const int cPlanDefend=22;\par
const int cPlanReserve=23;\par
const int cPlanGoal=24;\par
const int cPlanTower=25;\par
const int cPlanGatherGoal=26;\par
const int cPlanRepair=27;\par
const int cPlanTrade=28;\par
\par
//Plan States:\par
const int cPlanStateNone=0;\par
const int cPlanStateDone=1;\par
const int cPlanStateFailed=2;\par
const int cPlanStateBuild=3;\par
const int cPlanStateGather=4;\par
const int cPlanStatePlace=5;\par
const int cPlanStateExplore=6;\par
const int cPlanStateTrain=7;\par
const int cPlanStateResearch=8;\par
const int cPlanStateAttack=9;\par
const int cPlanStateGoto=10;\par
const int cPlanStateEmpower=11;\par
const int cPlanStateEnter=12;\par
const int cPlanStateExit=13;\par
const int cPlanStateEvaluate=14;\par
const int cPlanStatePatrol=15;\par
const int cPlanStateRetreat=16;\par
const int cPlanStateWorking=17;\par
const int cPlanStateTransport=18;\par
const int cPlanStateDualPlace=19;\par
const int cPlanStateWait=20;\par
const int cPlanStateCast=21;\par
\par
//Plan Events:\par
const int cPlanEventDone=0;\par
const int cPlanEventFailed=1;\par
const int cPlanEventPoll=2;\par
const int cPlanEventIdle=3;\par
\par
//Gather Plan Variables:\par
const int cGatherPlanMaximumDistance=0;\par
const int cGatherPlanMaximumWalkDistance=1;\par
const int cGatherPlanKBResourceID=2;\par
const int cGatherPlanAutoBuildDropsite=3;\par
const int cGatherPlanResourceID=4;\par
const int cGatherPlanResourceType=5;\par
const int cGatherPlanResourceSubType=6;\par
const int cGatherPlanBreakDownID=7;\par
const int cGatherPlanDropsiteTimeLimit=8;\par
const int cGatherPlanDropsiteTime=9;\par
const int cGatherPlanDropsiteID=10;\par
const int cGatherPlanDropsitePUID=11;\par
\par
//Build Plan Variables:\par
const int cBuildPlanBuildingPlacementID=0; (RO=0, AC=1).\par
const int cBuildPlanBuildingTypeID=1; (RO=0, AC=1).\par
const int cBuildPlanInfluenceUnitTypeID=2; (RO=0, AC=1).\par
const int cBuildPlanInfluenceUnitDistance=3; (RO=0, AC=1).\par
const int cBuildPlanInfluenceUnitValue=4; (RO=0, AC=1).\par
const int cBuildPlanAreaID=5; (RO=0, AC=1).\par
const int cBuildPlanCenterPosition=6; (RO=0, AC=1).\par
const int cBuildPlanCenterPositionDistance=7; (RO=0, AC=1).\par
const int cBuildPlanBuildUnitID=8; (RO=0, AC=1).\par
const int cBuildPlanFoundationID=9; (RO=0, AC=0).\par
const int cBuildPlanInfluencePosition=10; (RO=0, AC=1).\par
const int cBuildPlanInfluencePositionDistance=11; (RO=0, AC=1).\par
const int cBuildPlanInfluencePositionValue=12; (RO=0, AC=1).\par
const int cBuildPlanDockPlacementPoint=13; (RO=0, AC=1).\par
const int cBuildPlanNumAreaBorderLayers=14; (RO=0, AC=1).\par
const int cBuildPlanBuildingBufferSpace=15; (RO=0, AC=1).\par
const int cBuildPlanSettlementPlacementPoint=16; (RO=0, AC=1).\par
const int cBuildPlanFailOnUnaffordable=17; (RO=0, AC=1).\par
const int cBuildPlanInfluenceKBResourceID=18; (RO=0, AC=1).\par
const int cBuildPlanRandomBPValue=19; (RO=0, AC=1).\par
const int cBuildPlanInfluenceAtBuilderPosition=20; (RO=0, AC=1).\par
const int cBuildPlanInfluenceBuilderPositionValue=21; (RO=0, AC=1).\par
const int cBuildPlanInfluenceBuilderPositionDistance=22; (RO=0, AC=1).\par
const int cBuildPlanRetries=23; (RO=0, AC=1).\par
const int cBuildPlanMaxRetries=24; (RO=0, AC=1).\par
const int cBuildPlanPendingCommands=25; (RO=0, AC=1).\par
const int cBuildPlanFailureCause=26; (RO=1, AC=1).\par
const int cBuildPlanFailureCauseFloat=27; (RO=1, AC=1).\par
const int cBuildPlanMaxCanPaths=28; (RO=1, AC=1).\par
const int cBuildPlanCanPathStartIndex=29; (RO=0, AC=1).\par
\par
//Train Plan Variables:\par
const int cTrainPlanBuildingID=0; (RO=0, AC=1).\par
const int cTrainPlanIntoArmyID=1; (RO=0, AC=1).\par
const int cTrainPlanIntoPlanID=2; (RO=0, AC=1).\par
const int cTrainPlanIntoBaseID=3; (RO=0, AC=1).\par
const int cTrainPlanNumberToTrain=4; (RO=0, AC=1).\par
const int cTrainPlanNumberToMaintain=5; (RO=0, AC=1).\par
const int cTrainPlanNumberTrained=6; (RO=1, AC=1).\par
const int cTrainPlanUnitType=7; (RO=0, AC=1).\par
const int cTrainPlanBuildFromType=8; (RO=0, AC=1).\par
const int cTrainPlanTrainedUnitID=9; (RO=1, AC=0).\par
const int cTrainPlanFrequency=10; (RO=0, AC=1).\par
const int cTrainPlanUseMultipleBuildings=11; (RO=0, AC=1).\par
const int cTrainPlanGatherPoint=12; (RO=0, AC=1).\par
const int cTrainPlanGatherTargetID=13; (RO=0, AC=1).\par
const int cTrainPlanMaintainBaseID=14; (RO=0, AC=1).\par
const int cTrainPlanMaintainAreaID=15; (RO=0, AC=1).\par
\par
//Explore Plan Variables:\par
const int cExplorePlanLOSMultiplier=0; (RO=0, AC=1).\par
const int cExplorePlanDoLoops=1; (RO=0, AC=1).\par
const int cExplorePlanDoneLoops=2; (RO=1, AC=1).\par
const int cExplorePlanNumberOfLoops=3; (RO=0, AC=1).\par
const int cExplorePlanPointsInLoop=4; (RO=0, AC=1).\par
const int cExplorePlanAvoidingAttackedAreas=5; (RO=0, AC=1).\par
const int cExplorePlanReExploreAreas=6; (RO=1, AC=1).\par
const int cExplorePlanLOSProtoUnitID=7; (RO=1, AC=1).\par
const int cExplorePlanBuildPosition=8; (RO=1, AC=1).\par
const int cExplorePlanBuilderUnitType=9; (RO=1, AC=1).\par
const int cExplorePlanCanBuildLOSProto=10; (RO=0, AC=1).\par
const int cExplorePlanHandleDamageTime=11; (RO=1, AC=1).\par
const int cExplorePlanHandleDamageFrequency=12; (RO=0, AC=1).\par
const int cExplorePlanQuitWhenPointIsVisible=13; (RO=0, AC=1).\par
const int cExplorePlanQuitWhenPointIsVisiblePt=14; (RO=0, AC=1).\par
\par
//Research Plan Variables:\par
const int cResearchPlanBuildingID=0; (RO=0, AC=1).\par
const int cResearchPlanBuildingTypeID=1; (RO=0, AC=1).\par
const int cResearchPlanTechID=2; (RO=0, AC=1).\par
const int cResearchPlanBuildingAbstractTypeID=3; (RO=0, AC=1).\par
\par
//Attack Plan Variables:\par
const int cAttackPlanPlayerID=0; (RO=0, AC=1).\par
const int cAttackPlanSpecificTargetID=1; (RO=0, AC=0).\par
const int cAttackPlanTargetTypeID=2; (RO=0, AC=0).\par
const int cAttackPlanQueryID=3; (RO=0, AC=0).\par
const int cAttackPlanAttackRouteID=4; (RO=0, AC=1).\par
const int cAttackPlanAttackRoutePattern=5; (RO=0, AC=1).\par
const int cAttackPlanGatherPoint=6; (RO=0, AC=1).\par
const int cAttackPlanGatherDistance=7; (RO=0, AC=1).\par
const int cAttackPlanTargetID=8; (RO=1, AC=0).\par
const int cAttackPlanMoveAttack=9; (RO=0, AC=1).\par
const int cAttackPlanNumberAttacks=10; (RO=1, AC=1).\par
const int cAttackPlanRefreshFrequency=11; (RO=0, AC=1).\par
const int cAttackPlanLastRefreshTime=12; (RO=1, AC=1).\par
const int cAttackPlanHandleDamageTime=13; (RO=1, AC=1).\par
const int cAttackPlanHandleDamageFrequency=14; (RO=0, AC=1).\par
const int cAttackPlanBaseAttackMode=15; (RO=0, AC=1).\par
const int cAttackPlanPathID=16; (RO=0, AC=1).\par
const int cAttackPlanFromGoalID=17; (RO=0, AC=1).\par
const int cAttackPlanRetreatMode=18; (RO=0, AC=1).\par
const int cAttackPlanTargetAreaGroups=19; (RO=0, AC=0).\par
const int cAttackPlanTeleportLocation=20; (RO=1, AC=1).\par
const int cAttackPlanAutoUseGPs=21; (RO=0, AC=1).\par
const int cAttackPlanPowerID=22; (RO=1, AC=1).\par
const int cAttackPlanAttackRoutePatternLRU=0;\par
const int cAttackPlanAttackRoutePatternMRU=1;\par
const int cAttackPlanAttackRoutePatternRandom=2;\par
const int cAttackPlanAttackRoutePatternBest=3;\par
const int cAttackPlanBaseAttackModeNone=0;\par
const int cAttackPlanBaseAttackModeWeakest=1;\par
const int cAttackPlanBaseAttackModeStrongest=2;\par
const int cAttackPlanBaseAttackModeLRU=3;\par
const int cAttackPlanBaseAttackModeMRU=4;\par
const int cAttackPlanBaseAttackModeRandom=5;\par
const int cAttackPlanBaseAttackModeClosest=6;\par
const int cAttackPlanBaseAttackModeFarthest=7;\par
const int cAttackPlanRetreatModeNone=0;\par
const int cAttackPlanRetreatModeOutnumbered=1;\par
const int cAttackPlanRetreatModeWillLose=2;\par
\par
//Progression Plan Variables:\par
const int cProgressionPlanPollingTime=0; (RO=0, AC=1).\par
const int cProgressionPlanProgressionID=1; (RO=0, AC=1).\par
const int cProgressionPlanTrainUnitAtEnd=2; (RO=0, AC=1).\par
const int cProgressionPlanNumGoalUnitsToBuild=3; (RO=0, AC=1).\par
const int cProgressionPlanGoalUnitID=4; (RO=0, AC=1).\par
const int cProgressionPlanGoalTechID=5; (RO=0, AC=1).\par
const int cProgressionPlanBuildAreaID=6; (RO=0, AC=1).\par
const int cProgressionPlanCurrentGoalID=7; (RO=0, AC=1).\par
const int cProgressionPlanCurrentGoalType=8; (RO=0, AC=1).\par
const int cProgressionPlanCurrentStep=9; (RO=0, AC=1).\par
const int cProgressionPlanCurrentStepPlanID=10; (RO=0, AC=1).\par
const int cProgressionPlanPaused=11; (RO=0, AC=1).\par
const int cProgressionPlanAdvanceOneStep=12; (RO=0, AC=1).\par
const int cProgressionPlanRunInParallel=13; (RO=0, AC=1).\par
const int cProgressionPlanChildProgressions=14; (RO=0, AC=0).\par
const int cProgressionPlanBuildingPref=15; (RO=0, AC=1).\par
\par
//Build Wall Plan Variables:\par
const int cBuildWallPlanWallType=0; (RO=0, AC=1).\par
const int cBuildWallPlanWallStart=1; (RO=0, AC=1).\par
const int cBuildWallPlanWallEnd=2; (RO=0, AC=1).\par
const int cBuildWallPlanWallRingCenterPoint=3; (RO=0, AC=1).\par
const int cBuildWallPlanWallRingRadius=4; (RO=0, AC=1).\par
const int cBuildWallPlanNumberOfGates=5; (RO=0, AC=1).\par
const int cBuildWallPlanAreaIDs=6; (RO=0, AC=1).\par
const int cBuildWallPlanFoundationID=7; (RO=0, AC=1).\par
const int cBuildWallPlanGateIndices=8; (RO=0, AC=1).\par
const int cBuildWallPlanGateProtoIDs=9; (RO=0, AC=1).\par
const int cBuildWallPlanEdgeOfMapBuffer=10; (RO=0, AC=1).\par
const int cBuildWallPlanPieces=11; (RO=1, AC=1).\par
const int cBuildWallPlanPiecePositions=12; (RO=1, AC=1).\par
const int cBuildWallPlanPieceRotations=13; (RO=1, AC=1).\par
const int cBuildWallPlanEnRoute=14; (RO=0, AC=1).\par
\par
//Build Wall Plan Wall Types:\par
const int cBuildWallPlanWallTypeStraight=0;\par
const int cBuildWallPlanWallTypeRing=1;\par
const int cBuildWallPlanWallTypeArea=2;\par
\par
//Herd Plan Variables:\par
const int cHerdPlanBuildingID=0;\par
const int cHerdPlanBuildingTypeID=1;\par
const int cHerdPlanDistance=2;\par
\par
//Farm Plan Variables:\par
const int cFarmPlanDropsiteTypeID=0;\par
const int cFarmPlanDropsiteID=1;\par
const int cFarmPlanFarmingPosition=2;\par
const int cFarmPlanAutoBuildDropsite=3;\par
const int cFarmPlanResourceID=4;\par
const int cFarmPlanBreakDownID=5;\par
const int cFarmPlanResourceType=6;\par
const int cFarmPlanResourceSubType=7;\par
const int cFarmPlanFarmID=8;\par
\par
//Empower Plan Variables:\par
const int cEmpowerPlanTargetID=0;\par
const int cEmpowerPlanTargetTypeID=1;\par
\par
//Fish Plan Variables:\par
const int cFishPlanLandPoint=0; (RO=0, AC=1).\par
const int cFishPlanWaterPoint=1; (RO=0, AC=1).\par
const int cFishPlanLandGroupID=2; (RO=0, AC=1).\par
const int cFishPlanWaterGroupID=3; (RO=0, AC=1).\par
const int cFishPlanAutoTrainBoats=4; (RO=0, AC=1).\par
const int cFishPlanNumberInTraining=5; (RO=0, AC=1).\par
const int cFishPlanDockID=6; (RO=0, AC=1).\par
const int cFishPlanMaximumDockDist=7; (RO=0, AC=1).\par
const int cFishPlanPlaceRetries=8; (RO=0, AC=1).\par
const int cFishPlanMaxPlaceRetries=9; (RO=0, AC=1).\par
\par
//Transport Plan Variables:\par
const int cTransportPlanTransportID=0; (RO=0, AC=1).\par
const int cTransportPlanTransportTypeID=1; (RO=0, AC=1).\par
const int cTransportPlanGatherPoint=2; (RO=0, AC=1).\par
const int cTransportPlanTargetPoint=3; (RO=0, AC=1).\par
const int cTransportPlanGatherAreaGroup=4; (RO=0, AC=1).\par
const int cTransportPlanTargetAreaGroup=5; (RO=0, AC=1).\par
const int cTransportPlanGatherArea=6; (RO=0, AC=1).\par
const int cTransportPlanTargetArea=7; (RO=0, AC=1).\par
const int cTransportPlanPathType=8; (RO=0, AC=1).\par
const int cTransportPlanPathPlanned=9; (RO=0, AC=1).\par
const int cTransportPlanReturnWhenDone=10; (RO=0, AC=1).\par
const int cTransportPlanMaximizeXportMovement=11; (RO=0, AC=1).\par
const int cTransportPlanUnitsMoved=12; (RO=0, AC=0).\par
const int cTransportPlanIgnoreAreaIDs=13; (RO=0, AC=1).\par
const int cTransportPlanBestDangerArea=14; (RO=0, AC=1).\par
const int cTransportPlanBestDangerValue=15; (RO=0, AC=1).\par
const int cTransportPlanDropOffPoint=16; (RO=0, AC=1).\par
const int cTransportPlanPersistent=17; (RO=0, AC=1).\par
const int cTransportPlanMiddleAreaGroups=18; (RO=0, AC=0).\par
\par
//Repair Plan Variables:\par
const int cRepairPlanTargetID=0; (RO=0, AC=1).\par
\par
//Trade Plan Variables:\par
const int cTradePlanTargetUnitTypeID=0; (RO=0, AC=1).\par
const int cTradePlanTargetUnitID=1; (RO=0, AC=1).\par
const int cTradePlanStartPosition=2; (RO=0, AC=1).\par
const int cTradePlanTradeUnitType=3; (RO=0, AC=1).\par
const int cTradePlanTradeUnitTypeMax=4; (RO=0, AC=1).\par
const int cTradePlanMarketID=5; (RO=0, AC=1).\par
\par
//Dropoff Resource Plan Variables:\par
const int cDropoffResourcePlanBuildingID=0;\par
const int cDropoffResourcePlanBuildingTypeID=1;\par
\par
//Gather Relic Plan Variables:\par
const int cGatherRelicPlanDropsiteID=0; (RO=0, AC=1).\par
const int cGatherRelicPlanDropsiteTypeID=1; (RO=0, AC=1).\par
const int cGatherRelicPlanTargetID=2; (RO=0, AC=1).\par
const int cGatherRelicPlanTargetTypeID=3; (RO=0, AC=1).\par
const int cGatherRelicPlanTargetPosition=4; (RO=0, AC=1).\par
const int cGatherRelicPlanPickingUp=5; (RO=0, AC=1).\par
\par
//Attack Strategy Plan Variables:\par
const int cAttackStrategyPlanPlayerID=0; (RO=0, AC=0).\par
const int cAttackStrategyPlanNumberTotalAttacks=1; (RO=1, AC=1).\par
\par
//Defend Plan Variables:\par
const int cDefendPlanDefendTargetID=0; (RO=0, AC=0).\par
const int cDefendPlanDefendAreaID=1; (RO=0, AC=0).\par
const int cDefendPlanDefendBaseID=2; (RO=0, AC=0).\par
const int cDefendPlanDefendPoint=3; (RO=0, AC=0).\par
const int cDefendPlanEngageRange=4; (RO=0, AC=1).\par
const int cDefendPlanPatrol=5; (RO=0, AC=1).\par
const int cDefendPlanPatrolWaypoint=6; (RO=0, AC=0).\par
const int cDefendPlanCurrentWaypoint=7; (RO=0, AC=1).\par
const int cDefendPlanTargetID=8; (RO=1, AC=0).\par
const int cDefendPlanGatherDistance=9; (RO=0, AC=1).\par
const int cDefendPlanRefreshFrequency=10; (RO=0, AC=1).\par
const int cDefendPlanLastRefreshTime=11; (RO=1, AC=1).\par
const int cDefendPlanAttackTypeID=12; (RO=0, AC=0).\par
const int cDefendPlanGatherPercentage=13; (RO=0, AC=1).\par
\par
//Reserve Plan Variables:\par
const int cReservePlanPlanType=0; (RO=0, AC=0).\par
\par
//Goal Plan Variables:\par
const int cGoalPlanGoalType=0; (RO=0, AC=1).\par
const int cGoalPlanGoalSubType=1; (RO=0, AC=1).\par
const int cGoalPlanMinTime=2; (RO=0, AC=1).\par
const int cGoalPlanMaxTime=3; (RO=0, AC=1).\par
const int cGoalPlanMinAge=4; (RO=0, AC=1).\par
const int cGoalPlanMaxAge=5; (RO=0, AC=1).\par
const int cGoalPlanRepeat=6; (RO=0, AC=1).\par
const int cGoalPlanExecuteCount=7; (RO=0, AC=1).\par
const int cGoalPlanDoneGoal=8; (RO=0, AC=0).\par
const int cGoalPlanFailGoal=9; (RO=0, AC=0).\par
const int cGoalPlanExecuteGoal=10; (RO=0, AC=0).\par
const int cGoalPlanAutoUpdateState=11; (RO=0, AC=1).\par
const int cGoalPlanAutoUpdateBase=12; (RO=0, AC=1).\par
const int cGoalPlanAutoUpdateAttackPlayerID=13; (RO=0, AC=1).\par
const int cGoalPlanTargetType=14; (RO=0, AC=1).\par
const int cGoalPlanTarget=15; (RO=0, AC=1).\par
const int cGoalPlanTargetPoint=16; (RO=0, AC=1).\par
const int cGoalPlanTargetNumber=17; (RO=0, AC=1).\par
const int cGoalPlanMinUnitNumber=18; (RO=0, AC=1).\par
const int cGoalPlanMaxUnitNumber=19; (RO=0, AC=1).\par
const int cGoalPlanUnitPickerID=20; (RO=0, AC=1).\par
const int cGoalPlanUnitPickerFrequency=21; (RO=0, AC=1).\par
const int cGoalPlanUnitPickerTime=22; (RO=0, AC=1).\par
const int cGoalPlanAttackPlayerID=23; (RO=0, AC=1).\par
const int cGoalPlanAttackStartFrequency=24; (RO=0, AC=1).\par
const int cGoalPlanAttackStartTime=25; (RO=0, AC=1).\par
const int cGoalPlanUnitTypeID=26; (RO=0, AC=0).\par
const int cGoalPlanBaseID=27; (RO=0, AC=0).\par
const int cGoalPlanAllowRetreat=28; (RO=0, AC=1).\par
const int cGoalPlanUpgradeBuilding=29; (RO=0, AC=1).\par
const int cGoalPlanSetAreaGroups=30; (RO=0, AC=1).\par
const int cGoalPlanIdleAttack=31; (RO=0, AC=1).\par
const int cGoalPlanAreaGroupID=32; (RO=0, AC=0).\par
const int cGoalPlanFunctionID=33; (RO=0, AC=0).\par
const int cGoalPlanFunctionParm=34; (RO=0, AC=0).\par
const int cGoalPlanBuildingTypeID=35; (RO=0, AC=0).\par
const int cGoalPlanBuildingPlacementID=36; (RO=0, AC=0).\par
const int cGoalPlanBuildingSearchID=37; (RO=0, AC=0).\par
const int cGoalPlanActiveHealthTypeID=38; (RO=0, AC=1).\par
const int cGoalPlanActiveHealth=39; (RO=0, AC=1).\par
\par
//Goal Plan Goal Types:\par
const int cGoalPlanGoalTypeForwardBase=0;\par
const int cGoalPlanGoalTypeCreateBase=1;\par
const int cGoalPlanGoalTypeMainBase=2;\par
const int cGoalPlanGoalTypeAttack=3;\par
const int cGoalPlanGoalTypeDefend=4;\par
const int cGoalPlanGoalTypeTrain=5;\par
const int cGoalPlanGoalTypeMaintain=6;\par
const int cGoalPlanGoalTypeResearch=7;\par
const int cGoalPlanGoalTypeAge=8;\par
const int cGoalPlanGoalTypeCallback=9;\par
const int cGoalPlanGoalTypeBuilding=10;\par
const int cGoalPlanGoalTypeBuildSettlement=11;\par
\par
//Goal Plan Goal Sub Types:\par
const int cGoalPlanGoalSubTypeEmpty1=0;\par
const int cGoalPlanGoalSubTypeEmpty2=1;\par
\par
//Goal Plan Target Types:\par
const int cGoalPlanTargetTypeArea=0;\par
const int cGoalPlanTargetTypeAreaGroup=1;\par
const int cGoalPlanTargetTypePoint=2;\par
const int cGoalPlanTargetTypeUnitType=3;\par
const int cGoalPlanTargetTypeUnit=4;\par
const int cGoalPlanTargetTypePlayer=5;\par
const int cGoalPlanTargetTypePlayerRelation=6;\par
const int cGoalPlanTargetTypeTech=7;\par
\par
//Tower Plan Variables:\par
const int cTowerPlanCenterLocation=0; (RO=0, AC=1).\par
const int cTowerPlanAreaID=1; (RO=0, AC=1).\par
const int cTowerPlanDistanceFromCenter=2; (RO=0, AC=1).\par
const int cTowerPlanMaximizeLOS=3; (RO=0, AC=1).\par
const int cTowerPlanMaximizeAttack=4; (RO=0, AC=1).\par
const int cTowerPlanNumberToBuild=5; (RO=0, AC=1).\par
const int cTowerPlanBuildLocations=6; (RO=1, AC=1).\par
const int cTowerPlanProtoIDToBuild=7; (RO=0, AC=1).\par
const int cTowerPlanAttackLOSModifier=8; (RO=0, AC=1).\par
const int cTowerPlanLOSModifier=9; (RO=0, AC=1).\par
\par
//Gather Goal Plan Variables:\par
const int cGatherGoalPlanScriptRPGPct=0; (RO=0, AC=1).\par
const int cGatherGoalPlanCostRPGPct=1; (RO=0, AC=1).\par
const int cGatherGoalPlanGathererPct=2; (RO=0, AC=1).\par
const int cGatherGoalPlanNumFoodPlans=3; (RO=0, AC=1).\par
const int cGatherGoalPlanNumWoodPlans=4; (RO=0, AC=1).\par
const int cGatherGoalPlanNumGoldPlans=5; (RO=0, AC=1).\par
const int cGatherGoalPlanNumFavorPlans=6; (RO=0, AC=1).\par
const int cGatherGoalPlanMinResourceAmt=7; (RO=0, AC=1).\par
const int cGatherGoalPlanResourceCostWeight=8; (RO=0, AC=1).\par
const int cGatherGoalPlanFarmLimitPerPlan=9; (RO=0, AC=1).\par
const int cGatherGoalPlanMaxFarmLimit=10; (RO=0, AC=1).\par
const int cGatherGoalPlanResourceSkew=11; (RO=0, AC=1).\par
\par
//ProtoPower Constants:\par
const int cPowerLure=0;\par
const int cPowerBlessingofZeus=1;\par
const int cPowerBolt=2;\par
const int cPowerbramble=3;\par
const int cPowerBronze=4;\par
const int cPowerCeaseFireNomad=5;\par
const int cPowerCeaseFire=6;\par
const int cPowerCitadel=7;\par
const int cPowerDwarvenMine=8;\par
const int cPowerCurse=9;\par
const int cPowerEarthquake=10;\par
const int cPowerEclipse=11;\par
const int cPowerEnrage=12;\par
const int cPowerFlamingWeapons=13;\par
const int cPowerForestFire=14;\par
const int cPowerFrost=15;\par
const int cPowerGreatHunt=16;\par
const int cPowerHealingSpring=17;\par
const int cPowerInferno=18;\par
const int cPowerLightningStorm=19;\par
const int cPowerLocustSwarm=20;\par
const int cPowerMeteor=21;\par
const int cPowerNidhogg=22;\par
const int cPowerOmniscience=23;\par
const int cPowerOracle=24;\par
const int cPowerPestilence=25;\par
const int cPowerPlenty=26;\par
const int cPowerProsperity=27;\par
const int cPowerRagnorok=28;\par
const int cPowerRain=29;\par
const int cPowerRebellion=30;\par
const int cPowerRestoration=31;\par
const int cPowerShiftingSands=32;\par
const int cPowerSentinel=33;\par
const int cPowerPlagueofSerpents=34;\par
const int cPowershepherd=35;\par
const int cPowersight=36;\par
const int cPowerAncestors=37;\par
const int cPowerFimbulwinter=38;\par
const int cPowerSonofOsiris=39;\par
const int cPowerSPCMeteor=40;\par
const int cPowerSpy=41;\par
const int cPowerTornado=42;\par
const int cPowerUndermine=43;\par
const int cPowerUnderworldPassage=44;\par
const int cPowerVision=45;\par
const int cPowerWalkingWoods=46;\par
const int cPowerWellOfUrd=47;\par
const int cPowerwild=48;\par
\par
//Power Type Constants:\par
const int cPowerTypeGeneric=0;\par
const int cPowerTypeTempUnit=1;\par
const int cPowerTypeLightning=2;\par
const int cPowerTypeFrost=3;\par
const int cPowerTypeLocust=4;\par
const int cPowerTypeTeleport=5;\par
const int cPowerTypeMeteor=6;\par
const int cPowerTypeInferno=7;\par
const int cPowerTypeHealing=8;\par
const int cPowerTypeEnrage=9;\par
const int cPowerTypeClone=10;\par
const int cPowerTypeDamageUnit=11;\par
const int cPowerTypeTornado=12;\par
const int cPowerTypeRain=13;\par
const int cPowerTypeUndermine=14;\par
const int cPowerTypeSnowStorm=15;\par
const int cPowerTypeBronze=16;\par
const int cPowerTypePeace=17;\par
const int cPowerTypeProsperity=18;\par
const int cPowerTypeEclipse=19;\par
const int cPowerTypeShowUnit=20;\par
const int cPowerTypeBolt=21;\par
const int cPowerTypeSpy=22;\par
const int cPowerTypeTechActivate=23;\par
const int cPowerTypeAnimalMagnet=24;\par
const int cPowerTypeHealingSpring=25;\par
const int cPowerTypeSwapUnit=26;\par
const int cPowerTypeRebellion=27;\par
const int cPowerTypeSandstorm=28;\par
const int cPowerTypeEarthquake=29;\par
const int cPowerTypePlenty=30;\par
const int cPowerTypeForestFire=31;\par
const int cPowerTypeFlamingWeapons=32;\par
const int cPowerTypeDwarvenMines=33;\par
const int cPowerTypePestilence=34;\par
\par
//God Power Plan Variables:\par
const int cGodPowerPlanPowerTechID=0; (RO=0, AC=1).\par
const int cGodPowerPlanPowerProtoID=1; (RO=1, AC=1).\par
const int cGodPowerPlanCastNow=2; (RO=0, AC=1).\par
const int cGodPowerPlanAutoCast=3; (RO=0, AC=1).\par
const int cGodPowerPlanTargetingModel=4; (RO=0, AC=1).\par
const int cGodPowerPlanTargetLocation=5; (RO=0, AC=1).\par
const int cGodPowerPlanTargetUnit=6; (RO=0, AC=0).\par
const int cGodPowerPlanAttackPlanID=7; (RO=0, AC=1).\par
const int cGodPowerPlanResourceType=8; (RO=0, AC=0).\par
const int cGodPowerPlanEvaluationModel=9; (RO=0, AC=1).\par
const int cGodPowerPlanCount=10; (RO=0, AC=0).\par
const int cGodPowerPlanBPID=11; (RO=0, AC=0).\par
const int cGodPowerPlanBPBufferSpace=12; (RO=0, AC=1).\par
const int cGodPowerPlanDistance=13; (RO=0, AC=0).\par
const int cGodPowerPlanTargetHintLocation=14; (RO=1, AC=0).\par
const int cGodPowerPlanUnitTypeID=15; (RO=0, AC=1).\par
const int cGodPowerPlanType=16; (RO=1, AC=1).\par
const int cGodPowerPlanQueryID=17; (RO=0, AC=0).\par
const int cGodPowerPlanBuildingPlacementDistance=18; (RO=0, AC=1).\par
const int cGodPowerPlanBPInfluence=19; (RO=0, AC=0).\par
const int cGodPowerPlanBPInfluenceValue=20; (RO=0, AC=0).\par
const int cGodPowerPlanBPInfluenceDistance=21; (RO=0, AC=0).\par
const int cGodPowerPlanBPLocationPreference=22; (RO=0, AC=0).\par
const int cGodPowerPlanResourceSubType=23; (RO=0, AC=0).\par
const int cGodPowerPlanResourceFilterHuntable=24; (RO=0, AC=0).\par
const int cGodPowerPlanResourceFilterTotal=25; (RO=0, AC=0).\par
const int cGodPowerPlanQueryHitpointFilter=26; (RO=0, AC=0).\par
const int cGodPowerPlanTargetHintUnitID=27; (RO=1, AC=0).\par
const int cGodPowerPlanQueryPlayerID=28; (RO=0, AC=1).\par
const int cGodPowerPlanQueryPlayerRelation=29; (RO=0, AC=0).\par
const int cGodPowerPlanExplorePlanID=30; (RO=1, AC=0).\par
const int cGodPowerPlanCastAttempts=31; (RO=1, AC=1).\par
const int cGodPowerPlanCheckVisibility=32; (RO=0, AC=1).\par
\par
//GodPower Targeting Models:\par
const int cGodPowerTargetingModelUnit=0;\par
const int cGodPowerTargetingModelLocation=1;\par
const int cGodPowerTargetingModelDualUnit=2;\par
const int cGodPowerTargetingModelDualLocation=3;\par
const int cGodPowerTargetingModelWorld=4;\par
const int cGodPowerTargetingModelTown=5;\par
const int cGodPowerTargetingModelAttachedPlanLocation=6;\par
const int cGodPowerTargetingModelTownCenter=7;\par
const int cGodPowerTargetingModelMilitaryGatherPoint=8;\par
const int cGodPowerTargetingModelNearbyUnitType=9;\par
const int cGodPowerTargetingModelDualPlace=10;\par
\par
//GodPower Evaluation Models:\par
const int cGodPowerEvaluationModelNone=0;\par
const int cGodPowerEvaluationModelWorkers=1;\par
const int cGodPowerEvaluationModelCombatDistance=2;\par
const int cGodPowerEvaluationModelCombatDistanceSelf=3;\par
const int cGodPowerEvaluationModelQuery=4;\par
const int cGodPowerEvaluationModelKBResource=5;\par
\par
//GodPower Plan Types:\par
const int cGodPowerPlanTypeDefault=0;\par
const int cGodPowerPlanTypeRequiresAttackPlan=1;\par
\par
//Transport PathTypes:\par
const int cTransportPathTypePoints=0;\par
const int cTransportPathTypeAreas=1;\par
\par
//Resign Types:\par
const int cResignGatherers=0;\par
const int cResignSettlements=1;\par
const int cResignTeammates=2;\par
const int cResignMilitaryPop=3;\par
\par
//Unit Movement Types:\par
const int cMovementTypeNone=0;\par
const int cMovementTypeLand=1;\par
const int cMovementTypeWater=2;\par
const int cMovementTypeAir=4;\par
const int cMovementTypeNonSolid=8;\par
\par
//KB Unit States:\par
const int cUnitStateNone=0;\par
const int cUnitStateBuilding=1;\par
const int cUnitStateAlive=2;\par
const int cUnitStateDead=4;\par
const int cUnitStateAny=255;\par
const int cUnitStateAliveOrBuilding=3;\par
\par
//Building Placement Events:\par
const int cBuildingPlacementEventDone=0;\par
const int cBuildingPlacementEventFailed=1;\par
\par
//Unit Query Constants:\par
const int cUnitQueryNoArmy=-1;\par
const int cUnitQueryInvalidArmy=-1002;\par
\par
//Building Placement Preferences:\par
const int cBuildingPlacementPreferenceNone=-1;\par
const int cBuildingPlacementPreferenceBack=0;\par
const int cBuildingPlacementPreferenceFront=1;\par
const int cBuildingPlacementPreferenceLeft=2;\par
\par
//Civs:\par
const int cCivZeus=0;\par
const int cCivPoseidon=1;\par
const int cCivHades=2;\par
const int cCivIsis=3;\par
const int cCivRa=4;\par
const int cCivSet=5;\par
const int cCivOdin=6;\par
const int cCivThor=7;\par
const int cCivLoki=8;\par
const int cCivRandom=9;\par
const int cCivGreek=10;\par
const int cCivNorse=11;\par
const int cCivEgyptian=12;\par
const int cCivNature=13;\par
\par
//Cultures:\par
const int cCultureGreek=0;\par
const int cCultureEgyptian=1;\par
const int cCultureNorse=2;\par
const int cCultureNature=3;\par
\par
//Resources:\par
const int cResourceGold=0;\par
const int cResourceWood=1;\par
const int cResourceFood=2;\par
const int cResourceFavor=3;\par
const int cAllResources=-1234;\par
\par
//Unit Action Constants:\par
const int cActionBored=0;\par
const int cActionBuild=1;\par
const int cActionConvert=2;\par
const int cActionDeath=3;\par
const int cActionDecay=4;\par
const int cActionGather=5;\par
const int cActionHandAttack=6;\par
const int cActionHeal=7;\par
const int cActionHunting=8;\par
const int cActionIdle=9;\par
const int cActionMove=10;\par
const int cActionMoveByGroup=11;\par
const int cActionRangedAttack=12;\par
const int cActionRepair=13;\par
const int cActionResearch=14;\par
const int cActionTrain=15;\par
const int cActionOverrideAnimation=16;\par
const int cActionWork=17;\par
const int cActionAttack=18;\par
const int cActionUnused0=19;\par
const int cActionWander=20;\par
const int cActionEnter=21;\par
const int cActionAutoConvert=22;\par
const int cActionBirth=23;\par
const int cActionAreaAttack=24;\par
const int cActionFreeze=25;\par
const int cActionDormant=26;\par
const int cActionGatherPoint=27;\par
const int cActionMoveAttack=28;\par
const int cActionThrown=29;\par
const int cActionLightning=30;\par
const int cActionLight=31;\par
const int cActionJumpAttack=32;\par
const int cActionUnused1=33;\par
const int cActionMeteor=34;\par
const int cActionAttach=35;\par
const int cActionGuide=36;\par
const int cActionJumpMove=37;\par
const int cActionPickup=38;\par
const int cActionDiveBomb=39;\par
const int cActionUnused2=40;\par
const int cActionRegenerate=41;\par
const int cActionUse=42;\par
const int cActionEmpower=43;\par
const int cActionAutoGather=44;\par
const int cActionThrow=45;\par
const int cActionGore=46;\par
const int cActionDropoff=47;\par
const int cActionWhirlwindAttack=48;\par
const int cActionChargedRangedAttack=49;\par
const int cActionEject=50;\par
const int cActionFreezeAttack=51;\par
const int cActionConvertAttack=52;\par
const int cActionTrade=53;\par
const int cActionGuard=54;\par
const int cActionAutoMover=55;\par
const int cActionGetOnMover=56;\par
const int cActionSwallow=57;\par
const int cActionGate=58;\par
const int cActionLightningAttack=59;\par
const int cActionExplore=60;\par
const int cActionEat=61;\par
const int cActionBoost=62;\par
const int cActionCorpseDecay=63;\par
const int cActionTeleport=64;\par
const int cActionBuckAttack=65;\par
const int cActionTownBell=66;\par
const int cActionHeroDeath=67;\par
const int cActionHeroDeath=67;\par
\par
//Tech Status:\par
const int cTechStatusUnobtainable=0;\par
const int cTechStatusObtainable=1;\par
const int cTechStatusAvailable=2;\par
const int cTechStatusResearching=3;\par
const int cTechStatusActive=4;\par
const int cTechStatusPersistent=5;\par
\par
//Attack Routes:\par
const int cAttackRouteFrontRight=0;\par
const int cAttackRouteRightFront=1;\par
const int cAttackRouteRightBack=2;\par
const int cAttackRouteBackRight=3;\par
const int cAttackRouteBackLeft=4;\par
const int cAttackRouteLeftBack=5;\par
const int cAttackRouteLeftFront=6;\par
const int cAttackRouteFrontLeft=7;\par
\par
//Area Types:\par
const int cAreaTypeForest=1;\par
const int cAreaTypeWater=2;\par
const int cAreaTypeImpassableLand=3;\par
const int cAreaTypeGold=4;\par
const int cAreaTypeSettlement=5;\par
\par
//AreaGroup Types:\par
const int cAreaGroupTypeLand=0;\par
const int cAreaGroupTypeWater=1;\par
\par
//KB TechTree Unit Functions:\par
const int cUnitFunctionBuilder=0;\par
const int cUnitFunctionGatherer=1;\par
const int cUnitFunctionEmpower=2;\par
const int cUnitFunctionFish=3;\par
const int cUnitFunctionWaterTransport=4;\par
const int cUnitFunctionTrade=5;\par
const int cUnitFunctionUnknown=6;\par
\par
//KB TechTree Upgrade Types:\par
const int cUpgradeTypeAttack=0;\par
const int cUpgradeTypeArmor=1;\par
const int cUpgradeTypeHitpoints=2;\par
const int cUpgradeTypeSpeed=3;\par
const int cUpgradeTypeWorkRate=4;\par
const int cUpgradeTypeTrainPoints=5;\par
const int cUpgradeTypeAny=6;\par
\par
//KB TechTree Progression:\par
const int cProgressionTechNode=0;\par
const int cProgressionUnitNode=1;\par
\par
//Wall Types:\par
const int cWallTypeStraight=0;\par
const int cWallTypeRing=1;\par
const int cWallTypeArea=2;\par
\par
\par
\par
//Communications Constants:\par
\par
//Response Types:\par
const int cAICommResponseNoneRequired=0;\par
const int cAICommResponseWaiting=1;\par
const int cAICommResponseYes=2;\par
const int cAICommResponseNo=3;\par
const int cAICommResponseIncomingOrder=4;\par
\par
//AI Chat Types:\par
const int cAICommRecordPrompt=0;\par
const int cAICommRecordOrder=1;\par
const int cAICommRecordStatement=2;\par
\par
//Prompt Types:\par
const int cAICommPromptNone=0;\par
const int cAICommPromptAIBuildSettlement=1;\par
const int cAICommPromptAIResignGatherers=2;\par
const int cAICommPromptAIResignSettlements=3;\par
const int cAICommPromptAIResignActiveEnemies=4;\par
const int cAICommPromptIntro=5;\par
const int cAICommPromptGenericGodPower=6;\par
const int cAICommPromptOffensiveGodPower=7;\par
const int cAICommPromptEconomicGodPower=8;\par
const int cAICommPromptAILostSettlement=9;\par
const int cAICommPromptAILostLastSettlement=10;\par
const int cAICommPromptEnemyBuildSettlement=11;\par
const int cAICommPromptEnemyLostSettlement=12;\par
const int cAICommPromptEnemyLostLastSettlement=13;\par
const int cAICommPromptAIWinningAgeRace=14;\par
const int cAICommPromptAILosingAgeRace=15;\par
const int cAICommPromptAIWonderDestroyed=16;\par
const int cAICommPromptPlayerWonderDestroyed=17;\par
const int cAICommPromptPlayerBuildingWalls=18;\par
const int cAICommPromptAIAttack=19;\par
const int cAICommPromptAIAttackHere=20;\par
const int cAICommPromptAIRetreat=21;\par
const int cAICommPromptHelpHere=22;\par
const int cAICommPromptHelpHome=23;\par
const int cAICommPromptAITakeWater=24;\par
const int cAICommPromptTakingEnemyRelic=25;\par
const int cAICommPromptTakingAllyRelic=26;\par
const int cAICommPromptResignQuestion=27;\par
\par
//Techs: 387 total\par
const int cTechAge1=0;\par
const int cTechAge2=1;\par
const int cTechAge3=2;\par
const int cTechMediumArchers=3;\par
const int cTechHeavyArchers=4;\par
const int cTechChampionArchers=5;\par
const int cTechMediumInfantry=6;\par
const int cTechHeavyInfantry=7;\par
const int cTechChampionInfantry=8;\par
const int cTechHusbandry=9;\par
const int cTechPlow=10;\par
const int cTechIrrigation=11;\par
const int cTechCopperWeapons=12;\par
const int cTechBronzeWeapons=13;\par
const int cTechIronWeapons=14;\par
const int cTechCopperMail=15;\par
const int cTechBronzeMail=16;\par
const int cTechIronMail=17;\par
const int cTechCopperShields=18;\par
const int cTechBronzeShields=19;\par
const int cTechIronShields=20;\par
const int cTechAmbassadors=21;\par
const int cTechTaxCollectors=22;\par
const int cTechCoinage=23;\par
const int cTechMediumCavalry=24;\par
const int cTechHeavyCavalry=25;\par
const int cTechChampionCavalry=26;\par
const int cTechWatchTower=27;\par
const int cTechGuardTower=28;\par
const int cTechBallistaTower=29;\par
const int cTechBoilingOil=30;\par
const int cTechLevyInfantry=31;\par
const int cTechBurningPitch=32;\par
const int cTechMasons=33;\par
const int cTechPickaxe=34;\par
const int cTechHandAxe=35;\par
const int cTechShaftMine=36;\par
const int cTechBowSaw=37;\par
const int cTechQuarry=38;\par
const int cTechCarpenters=39;\par
const int cTechBravery=40;\par
const int cTechValleyoftheKings=41;\par
const int cTechLightningStorm=42;\par
const int cTechLocustSwarm=43;\par
const int cTechTornado=44;\par
const int cTechWinterHarvest=45;\par
const int cTechSafeguard=46;\par
const int cTechRampage=47;\par
const int cTechMithrilBreastplate=48;\par
const int cTechCallOfValhalla=49;\par
const int cTechArcticWinds=50;\par
const int cTechArcticGale=51;\par
const int cTechWrathOfTheDeep=52;\par
const int cTechSpiritedCharge=53;\par
const int cTechThunderingHooves=54;\par
const int cTechBerserkergang=55;\par
const int cTechRime=56;\par
const int cTechFrost=57;\par
const int cTechDraftHorses=58;\par
const int cTechEngineers=59;\par
const int cTechArchitects=60;\par
const int cTechMeteor=61;\par
const int cTechBoneBow=62;\par
const int cTechAxeofVengeance=63;\par
const int cTechDesertWind=64;\par
const int cTechEnclosedDeck=65;\par
const int cTechCladding=66;\par
const int cTechFortifiedWall=67;\par
const int cTechAge1Zeus=68;\par
const int cTechSkinOfTheRhino=69;\par
const int cTechAge15Egyptian=70;\par
const int cTechSacredCats=71;\par
const int cTechGraniteBlood=72;\par
const int cTechHamarrtroll=73;\par
const int cTechCriosphinx=74;\par
const int cTechHieracosphinx=75;\par
const int cTechMonstrousRage=76;\par
const int cTechPhobosSpearofPanic=77;\par
const int cTechBacchanalia=78;\par
const int cTechSunRay=79;\par
const int cTechSylvanLore=80;\par
const int cTechForgeofOlympus=81;\par
const int cTechAge1Hades=82;\par
const int cTechAge1Poseidon=83;\par
const int cTechCreateGold=84;\par
const int cTechAge1Ra=85;\par
const int cTechAge1Isis=86;\par
const int cTechAge1Set=87;\par
const int cTechAge1Odin=88;\par
const int cTechAge1Thor=89;\par
const int cTechAge1Loki=90;\par
const int cTechAuroraBorealis=91;\par
const int cTechAge2Athena=92;\par
const int cTechAge2Ares=93;\par
const int cTechAge2Hermes=94;\par
const int cTechAge3Dionysos=95;\par
const int cTechAge3Apollo=96;\par
const int cTechAge3Aphrodite=97;\par
const int cTechAge4Hera=98;\par
const int cTechAge4Artemis=99;\par
const int cTechAge4Hephaestus=100;\par
const int cTechHuntingDogs=101;\par
const int cTechHandofTalos=102;\par
const int cTechSarissa=103;\par
const int cTechAegisShield=104;\par
const int cTechWingedMessenger=105;\par
const int cTechAge2Anubis=106;\par
const int cTechAge2Bast=107;\par
const int cTechAge2Ptah=108;\par
const int cTechAge3Hathor=109;\par
const int cTechAge3Nephthys=110;\par
const int cTechAge3Sekhmet=111;\par
const int cTechAge4Thoth=112;\par
const int cTechAge4Osiris=113;\par
const int cTechAge4Horus=114;\par
const int cTechFeetoftheJackal=115;\par
const int cTechAge4=116;\par
const int cTechAge2Forseti=117;\par
const int cTechAge2Heimdall=118;\par
const int cTechAge2Freyja=119;\par
const int cTechAge3Skadi=120;\par
const int cTechAge3Bragi=121;\par
const int cTechAge3Njord=122;\par
const int cTechAge4Hel=123;\par
const int cTechAge4Baldr=124;\par
const int cTechAge4Tyr=125;\par
const int cTechSignalFires=126;\par
const int cTechStoneWall=127;\par
const int cTechShoulderofTalos=128;\par
const int cTechSkeletonPower=129;\par
const int cTechBookofThoth=130;\par
const int cTechFaceoftheGorgon=131;\par
const int cTechCitadelWall=132;\par
const int cTechUnderworldPassage=133;\par
const int cTechRestoration=134;\par
const int cTechConscriptInfantry=135;\par
const int cTechLevyArchers=136;\par
const int cTechConscriptArchers=137;\par
const int cTechLevyCavalry=138;\par
const int cTechConscriptCavalry=139;\par
const int cTechCarrierPigeons=140;\par
const int cTechFloodControl=141;\par
const int cTechPharaohRespawn=142;\par
const int cTechStartingUnitsNorse=143;\par
const int cTechStartingUnitsGreek=144;\par
const int cTechStartingUnitsEgyptian=145;\par
const int cTechGreatHunt=146;\par
const int cTechCeaseFire=147;\par
const int cTechMonument1=148;\par
const int cTechMonument2=149;\par
const int cTechMonument3=150;\par
const int cTechMonument4=151;\par
const int cTechUndermine=152;\par
const int cTechDwarvenMail=153;\par
const int cTechDwarvenShields=154;\par
const int cTechDwarvenWeapons=155;\par
const int cTechRain=156;\par
const int cTechSerpentSpear=157;\par
const int cTechFloodoftheNile=158;\par
const int cTechVaultsofErebus=159;\par
const int cTechLordofHorses=160;\par
const int cTechOlympicParentage=161;\par
const int cTechPigSticker=162;\par
const int cTechLoneWanderer=163;\par
const int cTechEyesintheForest=164;\par
const int cTechScallopedAxe=165;\par
const int cTechRingGiver=166;\par
const int cTechLongSerpent=167;\par
const int cTechSwineArray=168;\par
const int cTechAge15Norse=169;\par
const int cTechAge15Greek=170;\par
const int cTechOdinsRavenRespawn=171;\par
const int cTechSnowStorm=172;\par
const int cTechHeavyCamelry=173;\par
const int cTechChampionCamelry=174;\par
const int cTechBronze=175;\par
const int cTechPharaohRespawnOsiris=176;\par
const int cTechNewKingdom=177;\par
const int cTechMedjay=178;\par
const int cTechFuneralRites=179;\par
const int cTechSpiritofMaat=180;\par
const int cTechCityoftheDead=181;\par
const int cTechFortifyTownCenter=182;\par
const int cTechHeroesZeusAge2=183;\par
const int cTechHeroesZeusAge3=184;\par
const int cTechHeroesZeusAge4=185;\par
const int cTechHeroesPoseidonAge2=186;\par
const int cTechHeroesPoseidonAge3=187;\par
const int cTechHeroesPoseidonAge4=188;\par
const int cTechHeroesHadesAge2=189;\par
const int cTechHeroesHadesAge3=190;\par
const int cTechHeroesHadesAge4=191;\par
const int cTechShaduf=192;\par
const int cTechMonument0=193;\par
const int cTechRelicAnkhofRa=194;\par
const int cTechRelicEyeofHorus=195;\par
const int cTechRelicSistrumofBast=196;\par
const int cTechRelicHeadofOrpheus=197;\par
const int cTechRelicRingoftheNibelung=198;\par
const int cTechRelicStaffofDionysus=199;\par
const int cTechRelicFettersofFenrir=200;\par
const int cTechRelicOdinsSpear=201;\par
const int cTechRelicKitharaofApollo=202;\par
const int cTechRelicMithrilHorseshoes=203;\par
const int cTechRelicBowofArtemis=204;\par
const int cTechRelicWedjatEye=205;\par
const int cTechRelicNoseoftheSphinx=206;\par
const int cTechGoldenApples=207;\par
const int cTechEldhrimnirKettle=208;\par
const int cTechRelicArrowsofAlfar=209;\par
const int cTechRelicToothedArrows=210;\par
const int cTechRelicWandofGambantein=211;\par
const int cTechProsperity=212;\par
const int cTechPegasusRelicRespawn=213;\par
const int cTechRelicGoldenBridleofPegasus=214;\par
const int cTechEclipse=215;\par
const int cTechWillofKronos=216;\par
const int cTechLabyrinthofMinos=217;\par
const int cTechFlamesofTyphon=218;\par
const int cTechDivineBlood=219;\par
const int cTechShaftsofPlague=220;\par
const int cTechBonusPoseidon=221;\par
const int cTechVision=222;\par
const int cTechBolt=223;\par
const int cTechSpy=224;\par
const int cTechFlamingWeapons=225;\par
const int cTechFlamingWeaponsActive=226;\par
const int cTechLossofLOS=227;\par
const int cTechSerpents=228;\par
const int cTechAnimalMagnetism=229;\par
const int cTechHealingSpring=230;\par
const int cTechCurse=231;\par
const int cTechSentinel=232;\par
const int cTechSandstorm=233;\par
const int cTechCitadel=234;\par
const int cTechWalkingWoods=235;\par
const int cTechRagnorok=236;\par
const int cTechNidhogg=237;\par
const int cTechPlenty=238;\par
const int cTechSonofOsiris=239;\par
const int cTechPharaohRespawnCityoftheDead=240;\par
const int cTechEarthquake=241;\par
const int cTechAthenianWall=242;\par
const int cTechHeroesHadesAge1=243;\par
const int cTechHeroesPoseidonAge1=244;\par
const int cTechHeroesZeusAge1=245;\par
const int cTechDwarvenAuger=246;\par
const int cTechPurseSeine=247;\par
const int cTechReinforcedHull=248;\par
const int cTechHuntressAxe=249;\par
const int cTechForestFire=250;\par
const int cTechPestilence=251;\par
const int cTechRelicTriosBow=252;\par
const int cTechRelicShardofBlueCrystal=253;\par
const int cTechRelicArmorofAchilles=254;\par
const int cTechRelicShipofFingernails=255;\par
const int cTechCrocodopolis=256;\par
const int cTechLeatherFrameShield=257;\par
const int cTechElectrumBullets=258;\par
const int cTechStonesofRedLinen=259;\par
const int cTechSpearontheHorizon=260;\par
const int cTechFeral=261;\par
const int cTechAnastrophe=262;\par
const int cTechTrierarch=263;\par
const int cTechThracianHorses=264;\par
const int cTechRelicShinglesofSteel=265;\par
const int cTechRelicEyeofOrnlu=266;\par
const int cTechRelicTuskoftheIronBoar=267;\par
const int cTechAssignLOS=268;\par
const int cTechRoarofOrthus=269;\par
const int cTechAtefCrown=270;\par
const int cTechConscriptSailors=271;\par
const int cTechNavalOxybeles=272;\par
const int cTechEnyosBowofHorror=273;\par
const int cTechDeimosSwordofDread=274;\par
const int cTechChampionElephants=275;\par
const int cTechHallofThanes=276;\par
const int cTechAdzeofWepwawet=277;\par
const int cTechSlingsoftheSun=278;\par
const int cTechRamoftheWestWind=279;\par
const int cTechSundriedMudBrick=280;\par
const int cTechFuneralBarge=281;\par
const int cTechNecropolis=282;\par
const int cTechDisableArmoryforThor=283;\par
const int cTechIronMailThor=284;\par
const int cTechBronzeMailThor=285;\par
const int cTechBronzeShieldsThor=286;\par
const int cTechBronzeWeaponsThor=287;\par
const int cTechIronShieldsThor=288;\par
const int cTechIronWeaponsThor=289;\par
const int cTechBurningPitchThor=290;\par
const int cTechHammeroftheGods=291;\par
const int cTechMeteoricIronMail=292;\par
const int cTechDragonscaleShields=293;\par
const int cTechTusksofApedemak=294;\par
const int cTechRelicPandorasBox=295;\par
const int cTechRelicHerasThundercloudShawl=296;\par
const int cTechRelicHarmoniasNecklace=297;\par
const int cTechRelicDwarfenCalipers=298;\par
const int cTechOracle=299;\par
const int cTechSonsofSleipnir=300;\par
const int cTechSetAge2Critter=301;\par
const int cTechSetAge3Critter=302;\par
const int cTechSetAge4Critter=303;\par
const int cTechPoseidonHippocampusRespawn=304;\par
const int cTechEgyptianbuildingbonus=305;\par
const int cTechOmniscience=306;\par
const int cTechMediumAxemen=307;\par
const int cTechHeavyAxemen=308;\par
const int cTechChampionAxemen=309;\par
const int cTechMediumSpearmen=310;\par
const int cTechHeavySpearmen=311;\par
const int cTechChampionSpearmen=312;\par
const int cTechHeavyChariots=313;\par
const int cTechChampionChariots=314;\par
const int cTechHeavyElephants=315;\par
const int cTechLevyBarracksSoldiers=316;\par
const int cTechConscriptBarracksSoldiers=317;\par
const int cTechLevyMigdolSoldiers=318;\par
const int cTechConscriptMigdolSoldiers=319;\par
const int cTechMediumSlingers=320;\par
const int cTechHeavySlingers=321;\par
const int cTechChampionSlingers=322;\par
const int cTechRelicGoldenLions=323;\par
const int cTechRelicMonkeyHead=324;\par
const int cTechLevyLonghouseSoldiers=325;\par
const int cTechConscriptLonghouseSoldiers=326;\par
const int cTechConscriptHillFortSoldiers=327;\par
const int cTechLevyHillFortSoldiers=328;\par
const int cTechThurisazRune=329;\par
const int cTechGoldenLionsRelicRespawn=330;\par
const int cTechMonkeyHeadRelicRespawn=331;\par
const int cTechRelicCanopicJarofImsety=332;\par
const int cTechRelicTowerofSestus=333;\par
const int cTechRelicTrojanGateHinge=334;\par
const int cTechSPCMeteor=335;\par
const int cTechOdinsFirstRavens=336;\par
const int cTechHeroesEgyptianAge1=337;\par
const int cTechWeakenAge1Units=338;\par
const int cTechSaltAmphora=339;\par
const int cTechMediumMigdolShadow=340;\par
const int cTechPoseidonFirstHippocampus=341;\par
const int cTechTempleofHealing=342;\par
const int cTechGreatestofFifty=343;\par
const int cTechCopperMailThor=344;\par
const int cTechCopperShieldsThor=345;\par
const int cTechCopperWeaponsThor=346;\par
const int cTechWeaponoftheTitans=347;\par
const int cTechAge2Fake=348;\par
const int cTechAge3Fake=349;\par
const int cTechAge4Fake=350;\par
const int cTechCrenellations=351;\par
const int cTechBlessingofZeus=352;\par
const int cTechRelicGirdleofHippolyta=353;\par
const int cTechSharedLOS=354;\par
const int cTechRelicPygmalionsStatue=355;\par
const int cTechRelicBlackLotus=356;\par
const int cTechDeathmatchGreek=357;\par
const int cTechDeathmatchEgyptian=358;\par
const int cTechDeathmatchNorse=359;\par
const int cTechCeasefireEffect=360;\par
const int cTechNorsebuildingbonus=361;\par
const int cTechLightningMode=362;\par
const int cTechFortifiedTents=363;\par
const int cTechDwarvenShieldsEffect=364;\par
const int cTechRelicHartersFolly=365;\par
const int cTechRelicScarabPendant=366;\par
const int cTechWellofUrd=367;\par
const int cTechRelicBootsofKickEverything=368;\par
const int cTechRelicAnvilofHephaestus=369;\par
const int cTechRelicPeltofArgus=370;\par
const int cTechRelicOsebergWagon=371;\par
const int cTechRelicBuhenFlagstone=372;\par
const int cTechRelicCatoblepasScales=373;\par
const int cTechRelicTailofCerberus=374;\par
const int cTechRelicBlanketofEmpressZoe=375;\par
const int cTechRelicKhopeshofHorus=376;\par
const int cTechCeaseFireNomad=377;\par
const int cTechEclipseActive=378;\par
const int cTechPlentyKOTHenable=379;\par
const int cTechStartingUnitsThor=380;\par
const int cTechSetAge1Critter=381;\par
const int cTechStartingResourcesEgyptian=382;\par
const int cTechStartingResourcesGreek=383;\par
const int cTechStartingResourcesNorse=384;\par
const int cTechRelicReedofNekhebet=385;\par
const int cTechWeakenTrojanGate=386;\par
\par
//Unit Types: 772 total.\par
const int cUnitTypeHawk=0;\par
const int cUnitTypePalmStump=1;\par
const int cUnitTypeBush=2;\par
const int cUnitTypeArrow=3;\par
const int cUnitTypeAxe=4;\par
const int cUnitTypeBlood=5;\par
const int cUnitTypeScarabBlood=6;\par
const int cUnitTypeWaypointFlag=7;\par
const int cUnitTypeMoveto=8;\par
const int cUnitTypeTestObject=9;\par
const int cUnitTypeYardstick=10;\par
const int cUnitTypeSmoke=11;\par
const int cUnitTypeCloud=12;\par
const int cUnitTypeTornado=13;\par
const int cUnitTypeRevealer=14;\par
const int cUnitTypeAttackRevealer=15;\par
const int cUnitTypeConstructionSmall=16;\par
const int cUnitTypeConstructionMedium=17;\par
const int cUnitTypeConstructionLarge=18;\par
const int cUnitTypeConstructionExtraLarge=19;\par
const int cUnitTypeIceBlock=20;\par
const int cUnitTypePapyrus=21;\par
const int cUnitTypeWave=22;\par
const int cUnitTypeRainfall=23;\par
const int cUnitTypeIceSheet=24;\par
const int cUnitTypeCamera=25;\par
const int cUnitTypeCameraMotionArrow=26;\par
const int cUnitTypeCameraStart=27;\par
const int cUnitTypeWhale=28;\par
const int cUnitTypeFirePit=29;\par
const int cUnitTypeRockSymbols=30;\par
const int cUnitTypeStalagmite=31;\par
const int cUnitTypeRunestone=32;\par
const int cUnitTypeRockSnow=33;\par
const int cUnitTypeWaterLilly=34;\par
const int cUnitTypeWaterReeds=35;\par
const int cUnitTypeSnowfall=36;\par
const int cUnitTypeMist=37;\par
const int cUnitTypeWaterfall=38;\par
const int cUnitTypeGarrisonFlag=39;\par
const int cUnitTypeCrate=40;\par
const int cUnitTypeRugs=41;\par
const int cUnitTypeMarketStall=42;\par
const int cUnitTypeCatapultShot=43;\par
const int cUnitTypeMiscObjects=44;\par
const int cUnitTypeInfernoFireGround=45;\par
const int cUnitTypeLightningStrike=46;\par
const int cUnitTypeBallistaShot=47;\par
const int cUnitTypeSplash=48;\par
const int cUnitTypeMiscStairs=49;\par
const int cUnitTypeCoralReef=50;\par
const int cUnitTypeHeroBirth=51;\par
const int cUnitTypeCinematicBlock=52;\par
const int cUnitTypeFootprintVillager=53;\par
const int cUnitTypeFlamingFootprint=54;\par
const int cUnitTypeIcyFootprint=55;\par
const int cUnitTypeOarFootprint=56;\par
const int cUnitTypeMeteor=57;\par
const int cUnitTypeLightningsparks=58;\par
const int cUnitTypeLightningScorch=59;\par
const int cUnitTypeDustSmall=60;\par
const int cUnitTypeDustMedium=61;\par
const int cUnitTypeDustLarge=62;\par
const int cUnitTypeArrowFlaming=63;\par
const int cUnitTypeLightningCloud=64;\par
const int cUnitTypeLightningRain=65;\par
const int cUnitTypeUIArmyBannerFurled=66;\par
const int cUnitTypeUIArmyBannerPlain=67;\par
const int cUnitTypeUIArmyBannerInfantry=68;\par
const int cUnitTypeUIArmyBannerCavalry=69;\par
const int cUnitTypeUIArmyBannerArcher=70;\par
const int cUnitTypeUIArmyBannerVillager=71;\par
const int cUnitTypeBloodGore=72;\par
const int cUnitTypeLightningSparksGround=73;\par
const int cUnitTypeHoofprint=74;\par
const int cUnitTypeFootprintMilitary=75;\par
const int cUnitTypeFireObject=76;\par
const int cUnitTypeUIHeroBanner=77;\par
const int cUnitTypeUIIdleVillagerBanner=78;\par
const int cUnitTypeGiantFootprint=79;\par
const int cUnitTypeShark=80;\par
const int cUnitTypeOrca=81;\par
const int cUnitTypeRockGraniteSmall=82;\par
const int cUnitTypeRockLimestoneSmall=83;\par
const int cUnitTypeGrass=84;\par
const int cUnitTypeSeagull=85;\par
const int cUnitTypeRockGraniteBig=86;\par
const int cUnitTypeRockLimestoneBig=87;\par
const int cUnitTypeRockSandstoneBig=88;\par
const int cUnitTypeRockSandstoneSmall=89;\par
const int cUnitTypeRockRiverSandy=90;\par
const int cUnitTypeRockRiverGrassy=91;\par
const int cUnitTypeRockRiverIcy=92;\par
const int cUnitTypeShiftingSandsIn=93;\par
const int cUnitTypeUIArmyBannerMyth=94;\par
const int cUnitTypeUIIdleMilitaryBanner=95;\par
const int cUnitTypeHeavenlight=96;\par
const int cUnitTypeShiftingSandsOut=97;\par
const int cUnitTypeShiftingSandsOutEffect=98;\par
const int cUnitTypeInfernoUnitFlame=99;\par
const int cUnitTypeRevealertoPlayer=100;\par
const int cUnitTypeSkeleton=101;\par
const int cUnitTypeSandDriftDune=102;\par
const int cUnitTypeSandDriftPlain=103;\par
const int cUnitTypeSandDriftPatch=104;\par
const int cUnitTypeHealingSFX=105;\par
const int cUnitTypeHealingAreaSFX=106;\par
const int cUnitTypeFrostDrift=107;\par
const int cUnitTypeDustDevil=108;\par
const int cUnitTypeFountain=109;\par
const int cUnitTypeFireWood=110;\par
const int cUnitTypeCampfire=111;\par
const int cUnitTypeColumns=112;\par
const int cUnitTypeColumnsFallen=113;\par
const int cUnitTypeColumnsBroken=114;\par
const int cUnitTypeMilestone=115;\par
const int cUnitTypeSign=116;\par
const int cUnitTypeCloneSFX=117;\par
const int cUnitTypeInvisibleRam=118;\par
const int cUnitTypeSpear=119;\par
const int cUnitTypeSlingStone=120;\par
const int cUnitTypeRain=121;\par
const int cUnitTypeSnowStorm=122;\par
const int cUnitTypeFertilePlantsSFX=123;\par
const int cUnitTypeCinematicrocks=124;\par
const int cUnitTypeCinematicTrees=125;\par
const int cUnitTypeCinematicDeadBodies=126;\par
const int cUnitTypeDestroyedBuildingsSmall=127;\par
const int cUnitTypeCinematicScorch=128;\par
const int cUnitTypeunderminegrounddecallong=129;\par
const int cUnitTypeunderminegrounddecalshort=130;\par
const int cUnitTypeunderminegrounddecalcorner=131;\par
const int cUnitTypeArmorGlowSmall=132;\par
const int cUnitTypeTornadoDebris=133;\par
const int cUnitTypeRaft=134;\par
const int cUnitTypeMeteorImpactWater=135;\par
const int cUnitTypeMeteorImpactGround=136;\par
const int cUnitTypeRainSmall=137;\par
const int cUnitTypeBallofFire=138;\par
const int cUnitTypeIncreaseProsperityLarge=139;\par
const int cUnitTypeIncreaseProsperitySmall=140;\par
const int cUnitTypeBalloffireimpact=141;\par
const int cUnitTypeDove=142;\par
const int cUnitTypeSnowDriftArchery=143;\par
const int cUnitTypeSnowDriftBarracks=144;\par
const int cUnitTypeSnowDriftStable=145;\par
const int cUnitTypeSnowDriftSettlements=146;\par
const int cUnitTypeSnowDriftTower=147;\par
const int cUnitTypeSnowDriftSiege=148;\par
const int cUnitTypeSnowDriftMajorTemple=149;\par
const int cUnitTypeTunnelOpening=150;\par
const int cUnitTypeVolley=151;\par
const int cUnitTypeHadesFire=152;\par
const int cUnitTypeRockGraniteSprite=153;\par
const int cUnitTypeVisionRevealer=154;\par
const int cUnitTypeBoltStrike=155;\par
const int cUnitTypeSpyEye=156;\par
const int cUnitTypeCurseSFX=157;\par
const int cUnitTypeSentinelBase=158;\par
const int cUnitTypeBoltScorch=159;\par
const int cUnitTypeCitadelSFX=160;\par
const int cUnitTypeVisionSFX=161;\par
const int cUnitTypeRagnorokSFX=162;\par
const int cUnitTypeFimbulwinterSFX=163;\par
const int cUnitTypePlentyFlare=164;\par
const int cUnitTypeOsirisLightning=165;\par
const int cUnitTypeOsirisSFX=166;\par
const int cUnitTypePriestProjectile=167;\par
const int cUnitTypeUIArmyBannerSiege=168;\par
const int cUnitTypeRockLimestoneSprite=169;\par
const int cUnitTypeRockSandstoneSprite=170;\par
const int cUnitTypePineStump=171;\par
const int cUnitTypeOakstump=172;\par
const int cUnitTypeEarthquake=173;\par
const int cUnitTypeBarrel=174;\par
const int cUnitTypePots=175;\par
const int cUnitTypeBrokenSiegeWeapons=176;\par
const int cUnitTypeKrakenBits=177;\par
const int cUnitTypeFlowers=178;\par
const int cUnitTypeSeaweed=179;\par
const int cUnitTypeFern=180;\par
const int cUnitTypeFlagNumbered=181;\par
const int cUnitTypeScorpionTail=182;\par
const int cUnitTypeGenericCorpse=183;\par
const int cUnitTypeWadjetSpit=184;\par
const int cUnitTypeHeroDeath=185;\par
const int cUnitTypePetosuchusBeam=186;\par
const int cUnitTypeEarthquakeCrackA=187;\par
const int cUnitTypeEarthquakeCrackB=188;\par
const int cUnitTypeEarthquakeCrackC=189;\par
const int cUnitTypeEarthquakeCrackD=190;\par
const int cUnitTypeForestFireSFX=191;\par
const int cUnitTypePetosuchusprojectile=192;\par
const int cUnitTypeRecognizer=193;\par
const int cUnitTypeManticoreBarb=194;\par
const int cUnitTypeArrowSplashSFX=195;\par
const int cUnitTypePetrobolosShot=196;\par
const int cUnitTypeUITownBellBanner=197;\par
const int cUnitTypePestilenceSFX1=198;\par
const int cUnitTypePestilenceSFX2=199;\par
const int cUnitTypeHeroDeathRevealer=200;\par
const int cUnitTypeTestomatic=201;\par
const int cUnitTypeGateRamDestroyed=202;\par
const int cUnitTypeSpearFlaming=203;\par
const int cUnitTypeDestroyedBuildingsMed=204;\par
const int cUnitTypeDestroyedBuildingsLarge=205;\par
const int cUnitTypeOsiris=206;\par
const int cUnitTypeSPCMeteor=207;\par
const int cUnitTypeAvalanche=208;\par
const int cUnitTypeEinheriarBoostSFX=209;\par
const int cUnitTypeArrowSignal=210;\par
const int cUnitTypeOsirisBirth=211;\par
const int cUnitTypeOsirisBoxGlow=212;\par
const int cUnitTypeUIBannerObjective=213;\par
const int cUnitTypeOakstumpburnt=214;\par
const int cUnitTypeFireObjectBig=215;\par
const int cUnitTypeSmokeBig=216;\par
const int cUnitTypeUIArmyBannerHero=217;\par
const int cUnitTypeMummyFlies=218;\par
const int cUnitTypeVulture=219;\par
const int cUnitTypeConversionSFX=220;\par
const int cUnitTypeUIArmyBannerNaval=221;\par
const int cUnitTypeFireHades=222;\par
const int cUnitTypeDestruction3x3=223;\par
const int cUnitTypeDestruction4x4=224;\par
const int cUnitTypeDestruction5x5=225;\par
const int cUnitTypeDestruction8x8=226;\par
const int cUnitTypeThorhammer=227;\par
const int cUnitTypeRegenerationSFX=228;\par
const int cUnitTypePoisonSFX=229;\par
const int cUnitTypeTaprootlarge=230;\par
const int cUnitTypeTaprootSmall=231;\par
const int cUnitTypeShadow=232;\par
const int cUnitTypeDestructionSettlement=233;\par
const int cUnitTypeDestruction2x2=234;\par
const int cUnitTypeDestruction1x1=235;\par
const int cUnitTypeUIArmyBannerCaravan=236;\par
const int cUnitTypeUIArmyBannerOxcart=237;\par
const int cUnitTypeMInePieces=238;\par
const int cUnitTypeUnderworldSmoke=239;\par
const int cUnitTypeUnderworldExplosion=240;\par
const int cUnitTypeUICloudBoarder=241;\par
const int cUnitTypeBloodCinematic=242;\par
const int cUnitTypeSkeletonGiant=243;\par
const int cUnitTypeSkeletonAnimal=244;\par
const int cUnitTypeShipwreck=245;\par
const int cUnitTypeRuins=246;\par
const int cUnitTypeRottingLog=247;\par
const int cUnitTypeUnderbrush=248;\par
const int cUnitTypeGrassTall=249;\par
const int cUnitTypeRockCliff=250;\par
const int cUnitTypeUIRangeIndicatorEgyptSFX=251;\par
const int cUnitTypeHarpy=252;\par
const int cUnitTypeBlowingLeaves=253;\par
const int cUnitTypeHawksbill=254;\par
const int cUnitTypeSnowDrift=255;\par
const int cUnitTypeBloodFlow=256;\par
const int cUnitTypeBallofFireinvisible=257;\par
const int cUnitTypeSplashFootprint=258;\par
const int cUnitTypeLavaBubbling=259;\par
const int cUnitTypeWoodPile1=260;\par
const int cUnitTypeWoodPile2=261;\par
const int cUnitTypeWoodPile3=262;\par
const int cUnitTypeTrident=263;\par
const int cUnitTypeDestructionCitadel=264;\par
const int cUnitTypeForestFireAttack=265;\par
const int cUnitTypeUIRangeIndicatorGreekSFX=266;\par
const int cUnitTypeUIRangeIndicatorNorseSFX=267;\par
const int cUnitTypeInvisibleGate=268;\par
const int cUnitTypeUIArmyBannerBuilding=269;\par
const int cUnitTypeWaterdecoration=270;\par
const int cUnitTypeFootprintCavalry=271;\par
const int cUnitTypeFootprintAnimalLarge=272;\par
const int cUnitTypeFootprintAnimalSmall=273;\par
const int cUnitTypeFootprintSiege=274;\par
const int cUnitTypeEvilCloudSFX=275;\par
const int cUnitTypeSmokeGiant=276;\par
const int cUnitTypeCrateSmall=277;\par
const int cUnitTypeCinematicWake=278;\par
const int cUnitTypeWeapons=279;\par
const int cUnitTypeFootprintGiant=280;\par
const int cUnitTypeFootprintElephant=281;\par
const int cUnitTypeFootprintWheel=282;\par
const int cUnitTypeFootprintHydra=283;\par
const int cUnitTypeFootprintPortableRam=284;\par
const int cUnitTypeFootprintScorpion=285;\par
const int cUnitTypeFootprintScarab=286;\par
const int cUnitTypeSpearman=287;\par
const int cUnitTypeAxeman=288;\par
const int cUnitTypeSlinger=289;\par
const int cUnitTypeRaidingCavalry=290;\par
const int cUnitTypeCamelry=291;\par
const int cUnitTypeDwarf=292;\par
const int cUnitTypeBarracks=293;\par
const int cUnitTypeDock=294;\par
const int cUnitTypeFarm=295;\par
const int cUnitTypeGranary=296;\par
const int cUnitTypeArmory=297;\par
const int cUnitTypeGate=298;\par
const int cUnitTypeMarket=299;\par
const int cUnitTypeStable=300;\par
const int cUnitTypeFortress=301;\par
const int cUnitTypeMonument=302;\par
const int cUnitTypeSiegeCamp=303;\par
const int cUnitTypeWonder=304;\par
const int cUnitTypeCyclops=305;\par
const int cUnitTypeGoat=306;\par
const int cUnitTypeWolf=307;\par
const int cUnitTypePine=308;\par
const int cUnitTypeStorehouse=309;\par
const int cUnitTypeScarab=310;\par
const int cUnitTypeBallista=311;\par
const int cUnitTypeSiegeTower=312;\par
const int cUnitTypeCrocodile=313;\par
const int cUnitTypeHippo=314;\par
const int cUnitTypePalm=315;\par
const int cUnitTypeFlag=316;\par
const int cUnitTypeAnubite=317;\par
const int cUnitTypeBear=318;\par
const int cUnitTypeFireGiant=319;\par
const int cUnitTypeLocustSwarm=320;\par
const int cUnitTypeBoar=321;\par
const int cUnitTypeFrostGiant=322;\par
const int cUnitTypeWallLong=323;\par
const int cUnitTypeCatapult=324;\par
const int cUnitTypeCaravanNorse=325;\par
const int cUnitTypeTroll=326;\par
const int cUnitTypeMountainGiant=327;\par
const int cUnitTypeEinheriar=328;\par
const int cUnitTypeKraken=329;\par
const int cUnitTypeSeaTurtle=330;\par
const int cUnitTypeValkyrie=331;\par
const int cUnitTypeBattleBoar=332;\par
const int cUnitTypeTrireme=333;\par
const int cUnitTypeFishingShipGreek=334;\par
const int cUnitTypeBridge=335;\par
const int cUnitTypeCow=336;\par
const int cUnitTypeGiraffe=337;\par
const int cUnitTypeStatuePharaoh=338;\par
const int cUnitTypeTorch=339;\par
const int cUnitTypePig=340;\par
const int cUnitTypeLazerBear=341;\par
const int cUnitTypeZebra=342;\par
const int cUnitTypeWaterBuffalo=343;\par
const int cUnitTypeGazelle=344;\par
const int cUnitTypeBaboon=345;\par
const int cUnitTypeCentaur=346;\par
const int cUnitTypePhoenix=347;\par
const int cUnitTypeManticore=348;\par
const int cUnitTypeChimera=349;\par
const int cUnitTypeSphinx=350;\par
const int cUnitTypeMinotaur=351;\par
const int cUnitTypeHydra=352;\par
const int cUnitTypeChicken=353;\par
const int cUnitTypeMonkey=354;\par
const int cUnitTypeColossus=355;\par
const int cUnitTypeMummy=356;\par
const int cUnitTypeRoc=357;\par
const int cUnitTypeMedusa=358;\par
const int cUnitTypeObelisk=359;\par
const int cUnitTypeHadesDoor=360;\par
const int cUnitTypeAjax=361;\par
const int cUnitTypeArkantos=362;\par
const int cUnitTypeGargarensis=363;\par
const int cUnitTypeSetna=364;\par
const int cUnitTypeShabaKa=365;\par
const int cUnitTypeOdysseus=366;\par
const int cUnitTypeChiron=367;\par
const int cUnitTypeAmanra=368;\par
const int cUnitTypeWallConnector=369;\par
const int cUnitTypeWallShort=370;\par
const int cUnitTypeLeviathan=371;\par
const int cUnitTypeStatueLionRight=372;\par
const int cUnitTypeStatueLionLeft=373;\par
const int cUnitTypeEgyptianVulture=374;\par
const int cUnitTypeReginleif=375;\par
const int cUnitTypeScout=376;\par
const int cUnitTypeArcheryRange=377;\par
const int cUnitTypeScorpionMan=378;\par
const int cUnitTypeMinion=379;\par
const int cUnitTypeFishPerch=380;\par
const int cUnitTypeGreatBox=381;\par
const int cUnitTypeGreatBoxCart=382;\par
const int cUnitTypeGoldMine=383;\par
const int cUnitTypeKamos=384;\par
const int cUnitTypeOakTree=385;\par
const int cUnitTypePyramidLarge=386;\par
const int cUnitTypePyramidSmall=387;\par
const int cUnitTypeLion=388;\par
const int cUnitTypeRhinocerous=389;\par
const int cUnitTypeHyena=390;\par
const int cUnitTypeCrownedCrane=391;\par
const int cUnitTypeAurochs=392;\par
const int cUnitTypeFishMahi=393;\par
const int cUnitTypeFishSalmon=394;\par
const int cUnitTypeGiantDuckbilledPlatypus=395;\par
const int cUnitTypeTemple=396;\par
const int cUnitTypeHouse=397;\par
const int cUnitTypeTent=398;\par
const int cUnitTypeElephant=399;\par
const int cUnitTypeTunnel=400;\par
const int cUnitTypeTower=401;\par
const int cUnitTypeSettlement=402;\par
const int cUnitTypePegasus=403;\par
const int cUnitTypeScylla=404;\par
const int cUnitTypeAvenger=405;\par
const int cUnitTypeRaven=406;\par
const int cUnitTypeExcavation=407;\par
const int cUnitTypeGuardian=408;\par
const int cUnitTypeGuardianSleeping=409;\par
const int cUnitTypeSwordBearers=410;\par
const int cUnitTypeDeer=411;\par
const int cUnitTypeSettlementLevel1=412;\par
const int cUnitTypeOxCart=413;\par
const int cUnitTypeFenceStone=414;\par
const int cUnitTypeFenceWood=415;\par
const int cUnitTypeVillagerNorse=416;\par
const int cUnitTypeLonghouse=417;\par
const int cUnitTypeAcademy=418;\par
const int cUnitTypeVillagerGreek=419;\par
const int cUnitTypePortableRam=420;\par
const int cUnitTypeHillFort=421;\par
const int cUnitTypeVillagerEgyptian=422;\par
const int cUnitTypeThrowingAxeman=423;\par
const int cUnitTypeUlfsark=424;\par
const int cUnitTypeHuskarl=425;\par
const int cUnitTypeShrine=426;\par
const int cUnitTypeHeroNorse=427;\par
const int cUnitTypeHeroGreekAchilles=428;\par
const int cUnitTypePharaoh=429;\par
const int cUnitTypeLumberCamp=430;\par
const int cUnitTypeMiningCamp=431;\par
const int cUnitTypeHeroGreekOdysseus=432;\par
const int cUnitTypeHeroGreekChiron=433;\par
const int cUnitTypeHeroGreekPolyphemus=434;\par
const int cUnitTypeHoplite=435;\par
const int cUnitTypeHypaspist=436;\par
const int cUnitTypeHippikon=437;\par
const int cUnitTypeProdromos=438;\par
const int cUnitTypePeltast=439;\par
const int cUnitTypeToxotes=440;\par
const int cUnitTypePetrobolos=441;\par
const int cUnitTypeHelepolis=442;\par
const int cUnitTypePriest=443;\par
const int cUnitTypeMigdolStronghold=444;\par
const int cUnitTypeChariotArcher=445;\par
const int cUnitTypeMyrmidon=446;\par
const int cUnitTypeHetairoi=447;\par
const int cUnitTypeCataphract=448;\par
const int cUnitTypeMercenary=449;\par
const int cUnitTypeMonument2=450;\par
const int cUnitTypeMonument3=451;\par
const int cUnitTypeMonument4=452;\par
const int cUnitTypeMonument5=453;\par
const int cUnitTypeStatueofMajorGod=454;\par
const int cUnitTypeDwarvenForge=455;\par
const int cUnitTypeFolstagFlagBearer=456;\par
const int cUnitTypeTrojanHorse=457;\par
const int cUnitTypeBerryBush=458;\par
const int cUnitTypeBolderWall=459;\par
const int cUnitTypeMercenaryCavalry=460;\par
const int cUnitTypePirateShip=461;\par
const int cUnitTypeGateRam=462;\par
const int cUnitTypeJarl=463;\par
const int cUnitTypeWallLongDestructionSFX=464;\par
const int cUnitTypeWallShortDestructionSFX=465;\par
const int cUnitTypeWallConnectorDestructionSFX=466;\par
const int cUnitTypeOutpost=467;\par
const int cUnitTypeTransportShipGreek=468;\par
const int cUnitTypeKebenit=469;\par
const int cUnitTypeLongboat=470;\par
const int cUnitTypeLighthouse=471;\par
const int cUnitTypeHeroBoar=472;\par
const int cUnitTypeHeroGreekHeracles=473;\par
const int cUnitTypeHeroGreekJason=474;\par
const int cUnitTypeFishingShipNorse=475;\par
const int cUnitTypeFishingShipEgyptian=476;\par
const int cUnitTypeTransportShipEgyptian=477;\par
const int cUnitTypeTroyGate=478;\par
const int cUnitTypeTroyWallConnector=479;\par
const int cUnitTypeTroyWallLong=480;\par
const int cUnitTypeTroyWallShort=481;\par
const int cUnitTypeHeroGreekHippolyta=482;\par
const int cUnitTypeHeroGreekTheseus=483;\par
const int cUnitTypeHeroGreekBellerophon=484;\par
const int cUnitTypeHeroGreekAjax=485;\par
const int cUnitTypeHeroGreekAtalanta=486;\par
const int cUnitTypeHeroGreekPerseus=487;\par
const int cUnitTypeFlyingPurpleHippo=488;\par
const int cUnitTypeCaravanGreek=489;\par
const int cUnitTypeCaravanEgyptian=490;\par
const int cUnitTypeRelic=491;\par
const int cUnitTypeSkult=492;\par
const int cUnitTypeBolderRolling=493;\par
const int cUnitTypeGoldMineSmall=494;\par
const int cUnitTypePineSnow=495;\par
const int cUnitTypeCirce=496;\par
const int cUnitTypeStopCombat=497;\par
const int cUnitTypeNavalShipyard=498;\par
const int cUnitTypeRammingShipGreek=499;\par
const int cUnitTypeSiegeShipGreek=500;\par
const int cUnitTypeHeroGreekArgo=501;\par
const int cUnitTypeRammingShipNorse=502;\par
const int cUnitTypeRammingShipEgyptian=503;\par
const int cUnitTypeSiegeShipNorse=504;\par
const int cUnitTypeSiegeShipEgyptian=505;\par
const int cUnitTypeShade=506;\par
const int cUnitTypeAnimalAttractor=507;\par
const int cUnitTypeHealingSpringObject=508;\par
const int cUnitTypeSerpent=509;\par
const int cUnitTypeSentinelMain=510;\par
const int cUnitTypeCitadelCenter=511;\par
const int cUnitTypeWalkingWoodsPine=512;\par
const int cUnitTypeWalkingWoodsOak=513;\par
const int cUnitTypeWalkingWoodsPalm=514;\par
const int cUnitTypeHeroRagnorok=515;\par
const int cUnitTypeNidhogg=516;\par
const int cUnitTypeFimbulwinterWolf=517;\par
const int cUnitTypePlentyVault=518;\par
const int cUnitTypePharaohofOsiris=519;\par
const int cUnitTypeGoldMineDwarven=520;\par
const int cUnitTypeFenrisWolf=521;\par
const int cUnitTypeAthena=522;\par
const int cUnitTypeWalrus=523;\par
const int cUnitTypeWadjet=524;\par
const int cUnitTypePetsuchos=525;\par
const int cUnitTypeNemeanLion=526;\par
const int cUnitTypeAgamemnon=527;\par
const int cUnitTypeTheocrat=528;\par
const int cUnitTypeShadeofHades=529;\par
const int cUnitTypeAtlantisWallConnector=530;\par
const int cUnitTypeAtlantisWallLong=531;\par
const int cUnitTypeAtlantisGate=532;\par
const int cUnitTypeTamariskTree=533;\par
const int cUnitTypePhoenixEgg=534;\par
const int cUnitTypePolarBear=535;\par
const int cUnitTypeWalkingWoodsPineSnow=536;\par
const int cUnitTypeCaribou=537;\par
const int cUnitTypeElk=538;\par
const int cUnitTypePigSpecial=539;\par
const int cUnitTypeTitanBad=540;\par
const int cUnitTypePalmBurning=541;\par
const int cUnitTypeOakTreeBurning=542;\par
const int cUnitTypePineBurning=543;\par
const int cUnitTypeGreatBoxCart2=544;\par
const int cUnitTypeTransportShipNorse=545;\par
const int cUnitTypeThorHammerHaft=546;\par
const int cUnitTypeThorHammerHead=547;\par
const int cUnitTypePineSnowBurning=548;\par
const int cUnitTypeWarElephant=549;\par
const int cUnitTypeOakAutumn=550;\par
const int cUnitTypeBrokk=551;\par
const int cUnitTypeEitri=552;\par
const int cUnitTypeDwarfFoundry=553;\par
const int cUnitTypeHippocampus=554;\par
const int cUnitTypeOakAutumnBurning=555;\par
const int cUnitTypeSkraeling=556;\par
const int cUnitTypeUnderworldPassageSPC=557;\par
const int cUnitTypeCarcinos=558;\par
const int cUnitTypeJormundElver=559;\par
const int cUnitTypeMilitia=560;\par
const int cUnitTypeKastor=561;\par
const int cUnitTypeSeaSnake=562;\par
const int cUnitTypeOldMan=563;\par
const int cUnitTypeJailWall=564;\par
const int cUnitTypeDigPile=565;\par
const int cUnitTypeGoldenFleece=566;\par
const int cUnitTypeTempleUnderworld=567;\par
const int cUnitTypeArkantosman=568;\par
const int cUnitTypeBolderRollingDead=569;\par
const int cUnitTypeBolderRolling2=570;\par
const int cUnitTypePineDead=571;\par
const int cUnitTypeGateRam2=572;\par
const int cUnitTypeMiniAtlantis=573;\par
const int cUnitTypeAtlantisTile=574;\par
const int cUnitTypeAtlantisTileDead=575;\par
const int cUnitTypeWellofUrd=576;\par
const int cUnitTypeTroyGateDead=577;\par
const int cUnitTypePlentyVaultKOTH=578;\par
const int cUnitTypePoseidonStatue=579;\par
const int cUnitTypePharaohSecondary=580;\par
const int cUnitTypeSavannahTree=581;\par
const int cUnitTypeGoldenLion=582;\par
const int cUnitTypeMonkeyRelic=583;\par
const int cUnitTypeGhostShip=584;\par
const int cUnitTypeShadeofErebus=585;\par
const int cUnitTypeBanditMigdol=586;\par
const int cUnitTypeGoldMineTiny=587;\par
const int cUnitTypeWallMedium=588;\par
const int cUnitTypeStatueofLightning=589;\par
const int cUnitTypeCrossbowman=590;\par
const int cUnitTypeFenceIron=591;\par
const int cUnitTypeCharonFerry=592;\par
const int cUnitTypeHeroBoar2=593;\par
const int cUnitTypeTaproot=594;\par
const int cUnitTypeFemale=595;\par
const int cUnitTypeTheris=596;\par
const int cUnitTypeOrnlu=597;\par
const int cUnitTypePolaris=598;\par
const int cUnitTypeTamariskTreeDead=599;\par
const int cUnitTypePrisoner=600;\par
const int cUnitTypeFolstagFlag=601;\par
const int cUnitTypeUndermineBuildingDestructionSFX=602;\par
const int cUnitTypePineDeadBurning=603;\par
const int cUnitTypeApeofSet=604;\par
const int cUnitTypeGazelleofSet=605;\par
const int cUnitTypeHyenaofSet=606;\par
const int cUnitTypeCrocodileofSet=607;\par
const int cUnitTypeHippoofSet=608;\par
const int cUnitTypeRhinocerosofSet=609;\par
const int cUnitTypeGiraffeofSet=610;\par
const int cUnitTypeKrakenSPC=611;\par
const int cUnitTypeSavannahTreeBurning=612;\par
const int cUnitTypeWonderSPC=613;\par
const int cUnitTypeUnit=614;\par
const int cUnitTypeShip=615;\par
const int cUnitTypeBuilding=616;\par
const int cUnitTypeMilitaryBuilding=617;\par
const int cUnitTypeEconomicBuilding=618;\par
const int cUnitTypeDropsite=619;\par
const int cUnitTypeResource=620;\par
const int cUnitTypeHuntedResource=621;\par
const int cUnitTypeMinedResource=622;\par
const int cUnitTypeLandResource=623;\par
const int cUnitTypeWaterResource=624;\par
const int cUnitTypeProjectile=625;\par
const int cUnitTypeNature=626;\par
const int cUnitTypeSpecialPowers=627;\par
const int cUnitTypeUnattackable=628;\par
const int cUnitTypeAbstractTemple=629;\par
const int cUnitTypeMilitary=630;\par
const int cUnitTypeHero=631;\par
const int cUnitTypeTree=632;\par
const int cUnitTypeAbstractInfantry=633;\par
const int cUnitTypeAbstractCavalry=634;\par
const int cUnitTypeAbstractArcher=635;\par
const int cUnitTypeAbstractVillager=636;\par
const int cUnitTypeAbstractFarm=637;\par
const int cUnitTypeAbstractDock=638;\par
const int cUnitTypeInventoryHolder=639;\par
const int cUnitTypeInventoryItem=640;\par
const int cUnitTypeUseableItem=641;\par
const int cUnitTypeStrengthBonus=642;\par
const int cUnitTypeTradeableTo=643;\par
const int cUnitTypeTradeableFrom=644;\par
const int cUnitTypeAbstractSiegeWeapon=645;\par
const int cUnitTypeFlyingUnit=646;\par
const int cUnitTypeMythUnit=647;\par
const int cUnitTypeEconomic=648;\par
const int cUnitTypeRanged=649;\par
const int cUnitTypeFastSpeed=650;\par
const int cUnitTypeAverageSpeed=651;\par
const int cUnitTypeSlowSpeed=652;\par
const int cUnitTypeGeneric=653;\par
const int cUnitTypeUnitClass=654;\par
const int cUnitTypeBuildingClass=655;\par
const int cUnitTypeNatureClass=656;\par
const int cUnitTypeEmbellishmentClass=657;\par
const int cUnitTypeTestClass=658;\par
const int cUnitTypeE3Class=659;\par
const int cUnitTypeAll=660;\par
const int cUnitTypeActionGather=661;\par
const int cUnitTypeActionTrain=662;\par
const int cUnitTypeActionBuild=663;\par
const int cUnitTypeActionAttack=664;\par
const int cUnitTypeActionTrickle=665;\par
const int cUnitTypeFish=666;\par
const int cUnitTypeTransport=667;\par
const int cUnitTypeAbstractWall=668;\par
const int cUnitTypeHerdable=669;\par
const int cUnitTypeAbstractSettlement=670;\par
const int cUnitTypeBuildingsThatShoot=671;\par
const int cUnitTypeMythUnitGodPower=672;\par
const int cUnitTypeAge2Building=673;\par
const int cUnitTypeAge3Building=674;\par
const int cUnitTypeAge1Temple=675;\par
const int cUnitTypeFood=676;\par
const int cUnitTypeGold=677;\par
const int cUnitTypeWood=678;\par
const int cUnitTypeWildCrops=679;\par
const int cUnitTypeAge1Building=680;\par
const int cUnitTypeFoodDropsite=681;\par
const int cUnitTypeWoodDropsite=682;\par
const int cUnitTypeGoldDropsite=683;\par
const int cUnitTypeHumanSoldier=684;\par
const int cUnitTypeHuntable=685;\par
const int cUnitTypeAbstractMonument=686;\par
const int cUnitTypeSettlementsThatTrainVillagers=687;\par
const int cUnitTypeHack=688;\par
const int cUnitTypeCrush=689;\par
const int cUnitTypePierce=690;\par
const int cUnitTypeSharedBuilding=691;\par
const int cUnitTypeAbstractStable=692;\par
const int cUnitTypeAbstractFortress=693;\par
const int cUnitTypeAbstractBarracks=694;\par
const int cUnitTypeAbstractArcheryRange=695;\par
const int cUnitTypeEarlyWoodDropsite=696;\par
const int cUnitTypeEarlyFoodDropsite=697;\par
const int cUnitTypeEarlyGoldDropsite=698;\par
const int cUnitTypeConvertableBuilding=699;\par
const int cUnitTypeFavor=700;\par
const int cUnitTypeAnimalPrey=701;\par
const int cUnitTypeAnimalReactive=702;\par
const int cUnitTypeAnimalPredator=703;\par
const int cUnitTypeAbstractTradeUnit=704;\par
const int cUnitTypeAbstractPharaoh=705;\par
const int cUnitTypeMythUnitInfantry=706;\par
const int cUnitTypeMythUnitCavalry=707;\par
const int cUnitTypeMythUnitArcher=708;\par
const int cUnitTypeMythUnitSiege=709;\par
const int cUnitTypeUtilityShip=710;\par
const int cUnitTypeLogicalTypeHandUnitsAttack=711;\par
const int cUnitTypeLogicalTypePredatorsAutoAttack=712;\par
const int cUnitTypeLogicalTypeMeanPredatorsAutoAttack=713;\par
const int cUnitTypeLogicalTypeHandUnitsAutoAttack=714;\par
const int cUnitTypeLogicalTypePredatorsAttack=715;\par
const int cUnitTypeLogicalTypeScoutsRespondToAttack=716;\par
const int cUnitTypeLogicalTypeBuildingsNotHouses=717;\par
const int cUnitTypeLogicalTypeRangedUnitsAttack=718;\par
const int cUnitTypeLogicalTypeRangedUnitsAutoAttack=719;\par
const int cUnitTypeLogicalTypeUnitsNotBuildings=720;\par
const int cUnitTypeLogicalTypeDangerousAnimals=721;\par
const int cUnitTypeLogicalTypeIdleCivilian=722;\par
const int cUnitTypeLogicalTypeIdleMilitary=723;\par
const int cUnitTypeLogicalTypeTornadoAttack=724;\par
const int cUnitTypeLogicalTypeNeededForVictory=725;\par
const int cUnitTypeLogicalTypeIdleHero=726;\par
const int cUnitTypeLogicalTypeValidBoltTarget=727;\par
const int cUnitTypeLogicalTypeAffectedByHealingSpring=728;\par
const int cUnitTypeLogicalTypeAffectedByRestoration=729;\par
const int cUnitTypeLogicalTypeGarrisonOnBoats=730;\par
const int cUnitTypeLogicalTypeCavalryAndScout=731;\par
const int cUnitTypeLogicalTypeNonGreekUnit=732;\par
const int cUnitTypeLogicalTypeVillagersAttack=733;\par
const int cUnitTypeLogicalTypeEarthquakeAttack=734;\par
const int cUnitTypeAbstractArmory=735;\par
const int cUnitTypeLogicalTypeSiegeAutoAttack=736;\par
const int cUnitTypeLogicalTypeCanBeHealed=737;\par
const int cUnitTypeLogicalTypeMinimapFilterEconomic=738;\par
const int cUnitTypeLogicalTypeMinimapFilterMilitary=739;\par
const int cUnitTypeArcherShip=740;\par
const int cUnitTypeHammerShip=741;\par
const int cUnitTypeSiegeShip=742;\par
const int cUnitTypeAbstractCart=743;\par
const int cUnitTypeAbstractScout=744;\par
const int cUnitTypeLogicalTypeValidSpyTarget=745;\par
const int cUnitTypeAutoupgradedUnit=746;\par
const int cUnitTypeLogicalTypeNavalMilitary=747;\par
const int cUnitTypeLogicalTypeValidFrostTarget=748;\par
const int cUnitTypeLogicalTypeValidMeteorTarget=749;\par
const int cUnitTypeLogicalTypeSeaSerpentAttack=750;\par
const int cUnitTypeLogicalTypeFavoriteUnit=751;\par
const int cUnitTypeLogicalTypeFavoriteMythUnit=752;\par
const int cUnitTypeLogicalTypeConvertsHerds=753;\par
const int cUnitTypeLogicalTypeValidLocustSwarmTarget=754;\par
const int cUnitTypeLogicalTypeBuildingsNotWalls=755;\par
const int cUnitTypeLogicalTypeValidShiftingSandsTarget=756;\par
const int cUnitTypeLogicalTypeParticipatesInBattlecries=757;\par
const int cUnitTypeLogicalTypeBuildingsThatTrainMilitary=758;\par
const int cUnitTypeLogicalTypeRamAttack=759;\par
const int cUnitTypeLogicalTypeSiegeTowerUseRam=760;\par
const int cUnitTypeTransportShip=761;\par
const int cUnitTypeLogicalTypeVillagersRespondToAttack=762;\par
const int cUnitTypeLogicalTypeFimbulWinterTCEvalType=763;\par
const int cUnitTypeLogicalTypeValidForestFireTarget=764;\par
const int cUnitTypeLogicalTypeAutoattackTargetsBuildings=765;\par
const int cUnitTypeWalkingWood=766;\par
const int cUnitTypeLogicalTypeLandMilitary=767;\par
const int cUnitTypeLogicalTypeValidSPCUnitsDeadCondition=768;\par
const int cUnitTypeLogicalTypeAffectedByTownBell=769;\par
const int cUnitTypeLogicalTypeValidFlamingWeaponsTarget=770;\par
const int cUnitTypeLogicalTypeGreekHeroes=771;\par
\par
\par
\par
\b //Syscalls: 536 total.\par
\b0 void xsDisableRule( string ruleName )\par
\pard\fi720 Disables the given rule.\par
\par
\pard void xsDisableSelf( void )\par
\pard\fi720 Disables the current rule.\par
\par
\pard void xsEnableRule( string ruleName )\par
\pard\fi720 Enables the given rule.\par
\pard void xsSetRulePriority( string ruleName, int priority )\par
\pard\fi720 Sets the priority of the given rule.\par
\par
\pard void xsSetRulePrioritySelf( int priority )\par
\pard\fi720 Sets the priority of the current rule.\par
\par
\pard void xsSetRuleMinInterval( string ruleName, int interval )\par
\pard\fi720 Sets the min interval of the given rule.\par
\par
\pard void xsSetRuleMinIntervalSelf( int interval )\par
\pard\fi720 Sets the min interval of the current rule.\par
\par
\pard void xsSetRuleMaxInterval( string ruleName, int interval )\par
\pard\fi720 Sets the max interval of the given rule.\par
\par
\pard void xsSetRuleMaxIntervalSelf( int interval )\par
\pard\fi720 Sets the max interval of the current rule.\par
\par
\pard void xsEnableRuleGroup( string ruleGroupName )\par
\pard\fi720 Enables all rule in the given rule group.\par
\par
\pard void xsDisableRuleGroup( string ruleGroupName )\par
\pard\fi720 Disables all rules in the given rule group.\par
\par
\pard float xsVectorGetX( vector v )\par
\pard\fi720 Returns the x component of the given vector.\par
\par
\pard float xsVectorGetY( vector v )\par
\pard\fi720 Returns the y component of the given vector.\par
\par
\pard float xsVectorGetZ( vector v )\par
\pard\fi720 Returns the z component of the given vector.\par
\par
\pard float xsVectorSetX( vector v, float x )\par
\pard\fi720 Set the x component of the given vector, returns the new vector.\par
\par
\pard float xsVectorSetY( vector v, float y )\par
\pard\fi720 Set the y component of the given vector, returns the new vector.\par
\par
\pard float xsVectorSetZ( vector v, float z )\par
\pard\fi720 Set the z component of the given vector, returns the new vector.\par
\par
\pard float xsVectorSet( float x, float y, float z )\par
\pard\fi720 Set the 3 components into a vector, returns the new vector.\par
\par
\pard float xsVectorLength( vector v )\par
\pard\fi720 Returns the length of the given vector.\par
\par
\pard float xsVectorNormalize( vector v)\par
\pard\fi720 Returns the normalized version of the given vector.\par
\par
\pard int xsGetContextPlayer( void )\par
\pard\fi720 Returns the current context player ID.\par
\par
\pard void xsSetContextPlayer( int playerID )\par
\pard\fi720 Sets the current context player ID (DO NOT DO THIS IF YOU DO NOT KNOW \par
WHAT YOU ARE DOING).\par
\par
\pard int xsGetTime( void )\par
\pard\fi720 Returns the current gametime (in milliseconds).\par
\par
\pard bool xsAddRuntimeEvent( string foo, string bar, int something )\par
\pard\fi720 Setups a runtime event.  Don't use this.\par
\par
\pard int xsGetFuntionID( string functionName )\par
\pard\fi720 Runs the secret XSFID for the function. USE WITH CAUTION.\par
\par
\pard void aiEcho( string echoString )\par
\pard\fi720 CP AI echo.\par
\par
\pard void aiErrorMessage( string errorString )\par
\pard\fi720 CP AI error.\par
\par
\pard void aiRandSetSeed( int seed )\par
\pard\fi720 Sets the seed of the random number generator.\par
\par
\pard int aiRandInt( int max )\par
\pard\fi720 Returns a random number (mod'ed by max if provided).\par
\par
\pard vector aiRandLocation( void )\par
\pard\fi720 Returns a random location guaranteed to be on the map.\par
\par
\pard void aiSet( string filename, int playerID )\par
\pard\fi720 Sets playerID's AI to the given filename.\par
\par
\pard aiBreakpointSet( int playerID, string filename, int lineNumber, bool on )\par
\pard\fi720 Sets a breakpoint.\par
\par
\pard aiBreakpointGo( int playerID )\par
\pard\fi720 Restart XS execution after the current breakpoint.\par
\par
\pard string aiGetPersonality( void )\par
\pard\fi720 Gets the player's personality.\par
\par
\pard bool aiSetPersonality( string name )\par
\pard\fi720 Sets the player's personality.\par
\par
\pard int aiGetMostHatedPlayerID( void )\par
\pard\fi720 Returns the script-defined most hated player ID for this player.\par
\par
\pard void aiSetMostHatedPlayerID( int v )\par
\pard\fi720 Sets the script-defined most hated player ID for this player.\par
\par
\pard int aiGetAvailableEconomyPop( void )\par
\pard\fi720 Returns the available economy pop for this player.\par
\par
\pard int aiGetEconomyPop( void )\par
\pard\fi720 Returns the script-defined economy pop for this player.\par
\par
\pard void aiSetEconomyPop( int v )\par
\pard\fi720 Set the script-defined economy pop for this player.\par
\par
\pard int aiGetAvailableMilitaryPop( void )\par
\pard\fi720 Returns the script-defined military pop for this player.\par
\par
\pard int aiGetMilitaryPop( void )\par
\pard\fi720 Returns the script-defined military pop for this player.\par
\par
\pard void aiSetMilitaryPop( int v )\par
\pard\fi720 Set the script-defined military pop for this player.\par
\par
\pard float aiGetEconomyPercentage( void )\par
\pard\fi720 Returns the economy priority percentage.\par
\par
\pard void aiSetEconomyPercentage( float v )\par
\pard\fi720 Set the economy priority percentage.\par
\par
\pard float aiGetMilitaryPercentage( void )\par
\pard\fi720 Returns the militarypriority percentage.\par
\par
\pard void aiSetMilitaryPercentage( float v )\par
\pard\fi720 Set the military priority percentage.\par
\par
\pard float aiGetAttackResponseDistance( void )\par
\pard\fi720 Returns the attack response distance.\par
\par
\pard void aiSetAttackResponseDistance( float v )\par
\pard\fi720 Set the attack response distance.\par
\par
\pard int aiGoalGetNumber( int goalType, int goalState, bool active )\par
\pard\fi720 Returns the number of matching goals.\par
\par
\pard int aiGoalGetIDByIndex( int goalType, int goalState, bool active, int index )\par
\pard\fi720 Returns the ID of matching goal.\par
\par
\pard int aiPlanGetNumber( int planType, int planState, bool active )\par
\pard\fi720 Returns the number of matching plans.\par
\par
\pard int aiPlanGetIDByIndex( int planType, int planState, bool active, int index )\par
\pard\fi720 Returns the ID of matching plan.\par
\par
\pard int aiPlanCreate( string planName, int typeName )\par
\pard\fi720 Creates a plan of the given name and type.\par
\par
\pard bool aiPlanDestroy( int planID )\par
\pard\fi720 Destroys the given plan.\par
\par
\pard bool aiPlanDestroyByName( string name )\par
\pard\fi720 Destroys the plan of the given name.\par
\par
\pard int aiPlanGetID( string name )\par
\pard\fi720 Returns the ID of the plan with the given name.\par
\par
\pard int aiPlanGetIDByTypeAndVariableType( int planType, int varType, int varID, bool active )\par
\pard\fi720 Returns the ID of the plan with the given parms.\par
\par
\pard int aiPlanGetIDByActiveIndex( int activeIndex )\par
\pard\fi720 Returns the ID of the plan with the given active index.\par
\par
\pard string aiPlanGetType( int planID )\tab\par
\pard\fi720 Returns the name of the given plan.\par
\par
\pard int aiPlanGetType( int planID )\par
\pard\fi720 Returns the type of the given plan.\par
\par
\pard int aiPlanGetState( int planID )\par
\pard\fi720 Returns the state of the given plan.\par
\par
\pard int aiPlanGetActualPriority( int planID )\par
\pard\fi720 Returns the priority of the given plan.\par
\par
\pard int aiPlanGetDesiredPriority( int planID )\par
\pard\fi720 Returns the priority of the given plan.\par
\par
\pard bool aiPlanSetDesiredPriority( int planID, int priority )\par
\pard\fi720 Sets the priority of the given plan.\par
\par
\pard bool aiPlanAddUnitType(int planID, int unitTypeID, int numberNeed, \par
\pard\fi720\li1440 int numberWant, int numberMax )\par
\pard\fi720 Adds a unit type to the plan.\par
\par
\pard int aiPlanGetNumberUnits( int planID, int unitTypeID )\par
\pard\fi720 Returns the number of units currently assigned in the given plan.\par
\par
\pard bool aiPlanAddUnit( int planID, int unitID )\par
\pard\fi720 Adds a unit to the plan.\par
\par
\pard vector aiPlanGetLocation( int planID )\par
\pard\fi720 Returns the location for this plan.\par
\par
\pard vector aiPlanGetInitialPosition( int planID )\par
\pard\fi720 Returns the initial positon that was set for this plan.\par
\par
\pard void aiPlanSetInitialPosition( int planID, vector initialPosition )\par
\pard\fi720 Sets the initial positon for this plan.\par
\par
\pard bool aiPlanSetWaypoints( int planID, int pathID )\par
\pard\fi720 Sets the waypoints of the given plan to the waypoints of the given path.\par
\par
\pard bool aiPlanAddWaypoint( int planID, vector waypoint )\par
\pard\fi720 Adds the waypoint to the given plan.\par
\par
\pard int aiPlanGetNumberVariableValues( int planID, int planVariableIndex )\par
\pard\fi720 Returns the number of values for this variable index.\par
\par
\pard bool aiPlanSetNumberVariableValues( int planID, int planVariableIndex, int numberValues,\par
\pard\fi720\li2880 bool clearCurrentValues )\par
\pard\fi720 Sets the number of values for this variable.\par
\par
\pard bool aiPlanRemoveVariableValue( int planID, int planVariableIndex, int variableIndex )\par
\pard\fi720 Removes the index-th value of the variable.\par
\par
\pard bool aiPlanSetVariableInt( int planID, int planVariableIndex, int valueIndex, int value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard int aiPlanGetVariableInt( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanSetVariableFloat( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160 float value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard float aiPlanGetVariableFloat( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanSetVariableVector( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160 vector value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard vector aiPlanGetVariableVector( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanSetVariableBool( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160 bool value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard bool aiPlanGetVariableBool( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanSetVariableString( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160 string value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard string aiPlanGetVariableString( int planID, int planVariableIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard int aiPlanGetNumberUserVariableValues( int planID, int planVariableIndex )\par
\pard\fi720 Returns the number of values for this variable index.\par
\par
\pard bool aiPlanSetNumberUserVariableValues( int planID, int planVariableIndex, \par
\pard\li3600    int numberValues, bool clearCurrentValues )\par
\pard\fi720 Sets the number of values for this variable.\par
\par
\pard bool aiPlanRemoveUserVariables( int planID )\par
\pard\fi720 Removes all of the user variables from the given plan.\par
\par
\pard bool aiPlanRemoveUserVariable( int planID, int planVariableIndex )\par
\pard\fi720 Removes the user variable.\par
\par
\pard bool aiPlanRemoveUserVariableValue( int planID, int planVariableIndex, \par
\pard\fi720\li2880 int variableIndex )\par
\pard\fi720 Removes the index-th value of the user variable.\par
\par
\pard bool aiPlanAddUserVariableInt( int planID, int planVariableIndex, string name, \par
\pard\fi720\li2160  int numberValues )\par
\pard\fi720 Adds the variable to the given plan.\par
\par
\pard bool aiPlanSetUserVariableInt( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160  int value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard int aiPlanGetUserVariableInt( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanAddUserVariableFloat( int planID, int planVariableIndex, string name, \par
\pard\fi720\li2160    int numberValues )\par
\pard\fi720 Adds the variable to the given plan.\par
\par
\pard bool aiPlanSetUserVariableFloat( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160    float value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard float aiPlanGetUserVariableFloat( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanAddUserVariableVector( int planID, int planVariableIndex, string name, \par
\pard\fi720\li2160     int numberValues )\par
\pard\fi720 Adds the variable to the given plan.\par
\pard\par
bool aiPlanSetUserVariableVector( int planID, int planVariableIndex, int valueIndex,\par
\pard\fi720\li2160     vector value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard vector aiPlanGetUserVariableVector( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanAddUserVariableBool( int planID, int planVariableIndex, string name, \par
\pard\fi720\li2160   int numberValues )\par
\pard\fi720 Adds the variable to the given plan.\par
\par
\pard bool aiPlanSetUserVariableBool( int planID, int planVariableIndex, int valueIndex, \par
\pard\fi720\li2160   bool value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard bool aiPlanGetUserVariableBool( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanAddUserVariableString( int planID, int planVariableIndex, string name, \par
\pard\fi720\li2160     int numberValues )\par
\pard\fi720 Adds the variable to the given plan.\par
\par
\pard bool aiPlanSetUserVariableString( int planID, int planVariableIndex, int valueIndex,\par
\pard\li2880     string value )\par
\pard\fi720 Sets the given variable of the given plan.\par
\par
\pard string aiPlanGetUserVariableString( int planID, int planVariableIndex, int valueIndex )\par
\pard\fi720 Gets the given variable of the given plan.\par
\par
\pard bool aiPlanGetActive( int planID )\par
\pard\fi720 Gets the active-ness of the given plan.\par
\par
\pard bool aiPlanSetActive( int planID, bool active )\par
\pard\fi720 Sets active on/off for the given plan.\par
\par
\pard bool aiPlanGetNoMoreUnits( int planID )\par
\pard\fi720 Gets the noMoreUnits-ness of the given plan.\par
\par
\pard bool aiPlanSetNoMoreUnits( int planID, bool v )\par
\pard\fi720 Sets noMoreUnits on/off for the given plan.\par
\par
\pard bool aiPlanGetOrphan( int planID )\par
\pard\fi720 Gets the orphan-ness of the given plan.\par
\par
\pard bool aiPlanSetOrphan( int planID, bool orphan )\par
\pard\fi720 Sets orphan on/off for the given plan.\par
\par
\pard bool aiPlanGetAllowUnderAttackResponse( int planID )\par
\pard\fi720 Gets the UA response-ness of the given plan.\par
\par
\pard bool aiPlanSetAllowUnderAttackResponse( int planID, bool uAR )\par
\pard\fi720 Sets under attack response on/off for the given plan.\par
\par
\pard int aiPlanGetUnitStance( int planID )\par
\pard\fi720 Gets the unit stance of the given plan.\par
\par
\pard bool aiPlanSetUnitStance( int planID, int stance )\par
\pard\fi720 Sets unit stance for the given plan.\par
\par
\pard bool aiPlanSetRequiresAllNeedUnits( int planID, bool rANU )\par
\pard\fi720 Sets 'requiresAllNeedUnits' on/off for the given plan.\par
\par
\pard bool aiPlanSetEventHandler( int planID, int eventType, string handlerName )\par
\pard\fi720 Sets event handler function for the given plan and event.\par
\par
\pard bool aiPlanSetEscrowID( int planID, int escrowID )\par
\pard\fi720 Sets the escrow for the plan.\par
\par
\pard int aiPlanGetEscrowID( int planID )\par
\pard\fi720 Gets the escrow for the plan.\par
\par
\pard bool aiPlanGetEconomy( int planID )\par
\pard\fi720 Gets the economy flag of the given plan.\par
\par
\pard bool aiPlanSetEconomy( int planID, bool v )\par
\pard\fi720 Sets economy on/off for the given plan.\par
\par
\pard bool aiPlanGetMilitary( int planID )\par
\pard\fi720 Gets the military flag of the given plan.\par
\par
\pard bool aiPlanSetMilitary( int planID, bool v )\par
\pard\fi720 Sets military on/off for the given plan.\par
\par
\pard bool aiPlanGetAttack( int planID )\par
\pard\fi720 Gets the attack flag of the given plan.\par
\par
\pard bool aiPlanSetAttack( int planID, bool v )\par
\pard\fi720 Sets attack flag on/off for the given plan.\par
\par
\pard bool aiPlanSetBaseID( int planID, int baseID )\par
\pard\fi720 sets the plan's base id.\par
\par
\pard int aiPlanGetBaseID( int planID)\par
\pard\fi720 gets the plan's base id.\par
\par
\pard int aiGetNumberIdlePlans( int planType )\par
\pard\fi720 Gets the of idle plans of the given type.\par
\par
\pard int aiCommsSendPromptWithVector(targetPlayerID, int promptType, int textVariant, \par
\pard\fi720\li2160   float timeout, int yesOrderType, int noOrderType, \par
  int data1, vector position)\par
\pard\fi720 Sends a prompt to the designated player and sets up a response.\par
\par
\pard int aiCommsSendPrompt(targetPlayerID, int promptType, int textVariant, float timeout, \par
\pard\fi720\li1440 int yesOrderType, int noOrderType, int data1)\par
\pard\fi720 Sends a prompt to the designated player and sets up a response.\par
\par
\pard int aiCommsSendOrderWithVector(targetPlayerID, int promptType, int data1, \par
\pard\fi720\li2160  vector position)\par
\pard\fi720 Sends an order to the designated player.\par
\par
\pard int aiCommsSendOrder(targetPlayerID, int promptType, int data1)\par
\pard\fi720 Sends an order to the designated player.\par
\par
\pard int aiCommsSendStatement(targetPlayerID, int promptType, int textVariant)\par
\pard\fi720 Sends a statement to the designated player.\par
\par
\pard int aiCommsSendStatementWithVector(targetPlayerID, int promptType, int textVariant, vector v)\par
\pard\fi720 Sends a statement to the designated player. Adds a location flare.\par
\par
\pard bool aiCommsSetEventHandler(string handlerFunctionName )\par
\pard\fi720 Sets the handler for the communications system (invalid name unsets the handler).\par
\par
\pard bool aiCommsSetSpecificEventHandler(long recordID, string handlerFunctionName )\par
\pard\fi720 Sets the handler for a specific chat record in the comms system (invalid \par
name unsets the handler).\par
\par
\pard bool aiSetGodPowerEventHandler(string handlerFunctionName )\par
\pard\fi720 Sets the handler for god power casting events (invalid name unsets the handler).\par
\par
\pard bool aiSetBuildEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for building completed events (invalid name unsets the handler).\par
\par
\pard bool aiSetWonderDeathEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for wonder death events (invalid name unsets the handler).\par
\par
\pard bool aiSetRetreatEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for retreat events (invalid name unsets the handler).\par
\par
\pard bool aiSetRelicEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for relic events (invalid name unsets the handler).\par
\par
\pard bool aiSetResignEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for resign events (invalid name unsets the handler).\par
\par
\pard long aiCommsGetRecordType(int id)\par
\pard\fi720 Get the type of a given record.\par
\par
\pard long aiCommsGetRecordPromptType(int id)\par
\pard\fi720 Get the prompt type of a given record.\par
\par
\pard long aiCommsGetRecordPlayerID(int id)\par
\pard\fi720 Get the player ID of a given record.\par
\par
\pard long aiCommsGetRecordResponse(int id)\par
\pard\fi720 Get the response type of a given record.\par
\par
\pard long aiCommsGetResponseData(int id)\par
\pard\fi720 Get the response data of a given record.\par
\par
\pard long aiCommsGetRecordData(int id)\par
\pard\fi720 Get the data of a given record.\par
\par
\pard vector aiCommsGetRecordPosition(int id)\par
\pard\fi720 Get the position of a given record.\par
\par
\pard bool aiSetAgeEventHandler( int age, string handlerFunctionName )\par
\pard\fi720 Sets the handler for the given age (invalid name unsets the handler).\par
\par
\pard bool aiSetUpdateResourceEventHandler( string handlerFunctionName )\par
\pard\fi720 Sets the handler for the update resource event (invalid name unsets the handler).\par
\par
\pard bool aiSetUpdateResourceLimit( int resourceID, float limit )\par
\pard\fi720 Sets the limit for the given resource for the update resource event.\par
\par
\pard bool aiTaskUnitMove( int unitID, vector position )\par
\pard\fi720 Does a lightweight (no plan) move tasking of the given unit to the given location.\par
\par
\pard bool aiTaskUnitWork( int unitID, int targetUnitID )\par
\pard\fi720 Does a lightweight (no plan) work tasking of the given unit on the given target \par
unit.\par
\par
\pard bool aiTaskUnitBuild( int unitID, int buildingTypeID, vector position )\par
\pard\fi720 Does a lightweight (no plan) build tasking of the given unit to build the given \par
building.\par
\par
\pard bool aiTaskUnitTrain( int unitID, int unitTypeID )\par
\pard\fi720 Does a lightweight (no plan) train tasking of the given unit for the given target \par
unit type.\par
\par
\pard bool aiTaskUnitResearch( int unitID, int techID )\par
\pard\fi720 Does a lightweight (no plan) research tasking of the given unit for the given tech \par
ID.\par
\par
\pard bool aiTaskUnitSpecialPower( int unitID, int powerID, vector position )\par
\pard\fi720 Does a lightweight (no plan) research tasking of the given unit for the given \par
special power.\par
\par
\pard bool aiTaskUnitDelete( int unitID )\par
\pard\fi720 Deletes the given unit.\par
\par
\pard bool aiTribute( int playerID, int resourceID, float amount )\par
\pard\fi720 Tributes the given player.\par
\par
\pard bool aiUseMarket( int resourceID, float amount )\par
\pard\fi720 Buys (+amount) or sells (-amount) the given resource.\par
\par
\pard float aiGetMarketBuyCost( int resourceID )\par
\pard\fi720 Returns the amount required to buy 100 units of the given resource.\par
\par
\pard float aiGetMarketSellCost( int resourceID )\par
\pard\fi720 Returns the amount received for selling 100 units of the given resource.\par
\par
\pard float aiGetResourceGathererPercentageWeight( int rgpIndex )\par
\pard\fi720 Returns the RGP weight.\par
\par
\pard void aiSetResourceGathererPercentageWeight( int rgpIndex, float weight )\par
\pard\fi720 Sets the RGP weight.\par
\par
\pard void aiNormalizeResourceGathererPercentageWeights( void )\par
\pard\fi720 Normalizes all of the resource gatherer percentages weights to 1.0.\par
\par
\pard float aiGetResourceGathererPercentage( int resourceID, int rgpIndex )\par
\pard\fi720 Returns the resource gatherer percentage for the given resource.\par
\par
\pard void aiSetResourceGathererPercentage( int resourceID, float value, bool normalize, \par
\pard\fi720\li2880  int rgpIndex )\par
\pard\fi720 Sets the resource gatherer percentage for the given resource (if normalized is \par
true, the percentages will be normalized to 1.0).\par
\par
\pard void aiNormalizeResourceGathererPercentages( int rgpIndex )\par
\pard\fi720 Normalizes all of the resource gatherer percentages to 1.0.\par
\par
\pard int aiGetResourceBreakdownNumberPlans( int resourceTypeID, int resourceSubTypeID, \par
\pard\fi720\li2880   int baseID )\par
\pard\fi720 Gets the number of plans for the given breakdown.\par
\par
\pard int aiGetResourceBreakdownPlanPriority( int resourceTypeID, int resourceSubTypeID, \par
\pard\fi720\li2880    int baseID )\par
\pard\fi720 Gets the priority of the plans for the given breakdown.\par
\par
\pard float aiGetResourceBreakdownPercentage( int resourceTypeID, int resourceSubTypeID, \par
\pard\fi720\li2880    int baseID )\par
\pard\fi720 Gets the percentage for the given breakdown.\par
\par
\pard bool aiSetResourceBreakdown( int resourceTypeID, int resourceSubTypeID, int numberPlans,\par
\pard\fi720\li2160 int planPriority, float percentage, int baseID )\par
\pard\fi720 Sets a subtype breakdown for a resource.\par
\par
\pard bool aiRemoveResourceBreakdown( int resourceTypeID, int resourceSubTypeID, int baseID )\par
\pard\fi720 Removes the given breakdown.\par
\par
\pard int aiGetAutoGatherEscrowID( void )\par
\pard\fi720 Returns the auto gather escrow ID.\par
\par
\pard void aiSetAutoGatherEscrowID( int escrowID )\par
\pard\fi720 Sets the auto gather escrow ID.\par
\par
\pard int aiGetAutoFarmEscrowID( void )\par
\pard\fi720 Returns the auto Farm escrow ID.\par
\par
\pard void aiSetAutoFarmEscrowID( int escrowID )\par
\pard\fi720 Sets the auto Farm escrow ID.\par
\par
\pard int aiGetFarmLimit( void )\par
\pard\fi720 Returns the per plan farm build limit.\par
\par
\pard void aiSetFarmLimit( int limit )\par
\pard\fi720 Sets the per plan farm build limit.\par
\par
\pard int aiGetTrainedDropsiteUnitTypeID( void )\par
\pard\fi720 Returns the trained dropsite PUID.\par
\par
\pard void aiSetTrainedDropsiteUnitTypeID( int v )\par
\pard\fi720 Sets the trained dropsite PUID.\par
\par
\pard bool aiGetAutoFavorGather( void )\par
\pard\fi720 Returns auto favor gather on/off.\par
\par
\pard void aiSetAutoFavorGather( bool v )\par
\pard\fi720 Sets auto favor gather on/off.\par
\par
\pard bool aiGetAllowAutoDropsites( void )\par
\pard\fi720 Returns allow auto dropsites on/off.\par
\par
\pard void aiSetAllowAutoDropsites( bool v )\par
\pard\fi720 Sets allow auto dropsites on/off.\par
\pard\par
bool aiGetAllowBuildings( void )\par
\pard\fi720 Returns allow buildings on/off.\par
\par
\pard void aiSetAllowBuildings( bool v )\par
\pard\fi720 Sets allow buildings on/off.\tab\par
\pard\par
int aiWallInArea( string name, int areaID, int numberNeed, int nubmerWant, int numberMax,\par
\pard\fi720\li720    int escrowID, int numGates, int planPriority )\par
\pard\fi720 walls in the given area.\par
\par
\pard int aiWallInAreas( string name, int areaID1, int areaID2, int areaID3, int numberNeed,\par
\pard\fi720\li720     int nubmerWant, int numberMax, int escrowID, int numGates, \par
    int planPriority )\par
\pard\fi720 walls around all 3 areas at once.\par
\par
\pard int aiWallFromAToB( string name, vector a, vector b, int numberNeed, int nubmerWant, \par
\pard\li1440      int numberMax, int escrowID, int numGates, int planPriority )\par
\pard\fi720 walls from point a to point b.\par
\par
\pard int aiWallRingAroundPoint( string name, vector center, float radius, int numberNeed, \par
\pard\li2550 int nubmerWant, int numberMax, int escrowID, int numGates, int planPriority )\par
\pard\fi720 walls a ring around the center, with a given radius.\par
\par
\pard void aiChat( int playerID, string chatString )\par
\pard\fi720 CP AI chat to playerID.\par
\par
\pard void aiSendChatToEveryone( string chatString )\par
\pard\fi720 CP AI chat to everyone.\par
\par
\pard void aiSendChatToAllies( string chatString )\par
\pard\fi720 CP AI chat to allies.\par
\par
\pard void aiSendChatToEnemies( string chatString )\par
\pard\fi720 CP AI chat to enemies.\par
\par
\pard int aiNumberUnassignedUnits( int typeID )\par
\pard\fi720 Returns the number of unassigned units of the given type.\par
\par
\pard int aiNumberUnassignedUnitsByGoal( int goalID )\par
\pard\fi720 Returns the number of unassigned units based on the goal's unit type(s).\par
\par
\pard void aiResourceCheat( int playerID, int resourceID, float amount )\par
\pard\li720 Gives your wimpy CP AI free resources because it can't handle the truth, or something like that.\par
\par
\pard int aiUnitCreateCheat( int playerID, int protoUnitID, vector position, string name, \par
\pard\fi720\li1440  int numberUnits )\par
\pard\fi720 Creates unit(s) with the given parms.\par
\par
\pard bool aiCastGodPowerAtPosition( int godPowerTechID, vector pos)\par
\pard\fi720 Casts the given God power tech, at the specified position.\par
\par
\pard bool aiCastGodPowerAtUnit( int godPowerTechID, int unitID)\par
\pard\fi720 Casts the given God power tech, at the specified unit.\par
\par
\pard int aiGetGodPowerTechIDForSlot( int slotID)\par
\pard\fi720 Get the god power tech id from the given slot.\par
\par
\pard int aiGetGodPowerProtoIDForTechID( int techID)\par
\pard\fi720 translate a granted tech id into a protopower id\par
\par
\pard int aiGetGodPowerType( int protoPowerID)\par
\pard\fi720 get the type for a ProtoPower\par
\par
\pard int aiFindBestAttackGodPowerPlan(void)\par
\pard\fi720 find a valid god power plan to attach to an attack plan\par
\par
\pard int aiGetWorldDifficulty( void )\tab\par
\pard\fi720 Returns the world difficulty level.\par
\par
\pard void aiSetWorldDifficulty( int v )\par
\pard\fi720 Sets the world difficulty level.\par
\par
\pard string aiGetWorldDifficultyName( int level )\par
\pard\fi720 Returns the name of the level.\par
\par
\pard int aiGetGameMode( void )\par
\pard\fi720 Returns the game's mode.\par
\par
\pard int aiGetCaptainPlayerID( int playerID )\par
\pard\fi720 Returns the captain for the given player's team.\par
\par
\pard void aiAutoSavegame( string filename )\par
\pard\fi720 Saves the auto, debugging savegames.\par
\par
\pard bool aiGetAutosaveOn()\par
\pard\fi720 returns whether or not its cool to turn ai autosaves on.\par
\par
\pard void aiGetCurrentResourceNeed( int resourceID )\par
\pard\fi720 returns the current resource need for the given resource.\par
\par
\pard bool aiSetExploreDangerThreshold( float value)\par
\pard\fi720 sets the ai's Explore Danger Threshold value.\par
\par
\pard float aiGetExploreDangerThreshold()\par
\pard\fi720 gets the ai's Explore Danger Threshold value.\par
\par
\pard void aiSetPauseAllAgeUpgrades(bool v)\par
\pard\fi720 sets the pause all age upgrades flag in the AI.\par
\par
\pard bool aiGetPauseAllAgeUpgrades()\par
\pard\fi720 gets the pause all age upgrades flag from the AI.\par
\par
\pard void aiSetMinNumberNeedForGatheringAggressvies(long v)\par
\pard\fi720 sets the min number of needed units to gather aggressive animals.\par
\par
\pard int aiGetMinNumberNeedForGatheringAggressives()\par
\pard\fi720 gets the min number of needed units to gather aggressive animals.\par
\par
\pard void aiSetMinNumberWantForGatheringAggressives(long v)\par
\pard\fi720 sets the min number of wanted units to gather aggressive animals.\par
\par
\pard int aiGetMinNumberWantForGatheringAggressives()\par
\pard\fi720 gets the min number of wanted units to gather aggressive animals.\par
\par
\pard void aiResign()\par
\pard\fi720 reigns the current player..\par
\par
\pard void aiAttemptResign()\par
\pard\fi720 asks the player if its ok to resign\par
\par
\pard void aiSetMaxLOSProtoUnitLimit(int limit)\par
\pard\fi720 sets the limit for how many LOS Protounits the AI can build\par
\par
\pard int aiGetMaxLOSProtoUnitLimit()\par
\pard\fi720 gets the limit for how many LOS Protounits the AI can build\par
\par
\pard int aiGetPopNeeds()\par
\pard\fi720 gets the current Pop needs of all the plans.\par
\par
\pard void aiSwitchMainBase(int newBaseID, bool force)\par
\pard\fi720 switch the newBaseID to be the main base.\par
\par
\pard void kbEcho( string echoString )\par
\pard\fi720 Knowledge Base echo.\par
\par
\pard void kbDump( int player1, int player2 )\par
\pard\fi720 KB dump for player2's units from player1's perspective.\par
\par
\pard void kbDumpType( int player1, int player2, string typeName )\par
\pard\fi720 KB dump for player2's units of the given type from player1's perspective.\par
\par
\pard void kbLookAtAllUnitsOnMap( void )\tab\par
\pard\fi720 Cheats and looks at all of the units on the map.  This will format your harddrive\par
if you're not authorized to use it.\par
\par
\pard int kbGetPop( void )\par
\pard\fi720 Returns the current population for the player.\par
\par
\pard int kbGetPopCap( void )\par
\pard\fi720 Returns the current population cap for the player.\par
\par
\pard int kbGetAge( void )\par
\pard\fi720 Returns the current age for the current player.\par
\par
\pard int kbGetAgeForPlayer( int id )\par
\pard\fi720 Returns the current age for the player specified.\par
\par
\pard int kbGetCulture( void )\par
\pard\fi720 Returns the culture for the player.\par
\par
\pard string kbGetCulture( int cultureID )\par
\pard\fi720 Returns the culture name for the given culture.\par
\par
\pard int kbGetCiv( void )\par
\pard\fi720 Returns the civilization for the player.\par
\par
\pard string kbGetCivName( int civID )\par
\pard\fi720 Returns the civ name for the given civ.\par
\par
\pard int kbUnitQueryCreate( string name )\par
\pard\fi720 Creates a unit query, returns the query ID.\par
\par
\pard bool kbUnitQueryResetData( long queryID )\par
\pard\fi720 Resets the given unit query data AND results.\par
\par
\pard bool kbUnitQueryResetResults( long queryID )\par
\pard\fi720 Resets the given unit query results.\par
\par
\pard bool kbUnitQueryDestroy( long queryID )\par
\pard\fi720 Destroys the given unit query.\par
\par
\pard int kbUnitQueryNumberResults( long queryID )\par
\pard\fi720 Returns the number of results in the current query.\par
\par
\pard int kbUnitQueryGetResult( long queryID, int index )\par
\pard\fi720 Returns the UnitID of the index-th result in the current query.\par
\par
\pard bool kbUnitQuerySetPlayerID( long queryID, int playerID, bool resetQueryData )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetPlayerRelation( long queryID, int playerRelation )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetUnitType( long queryID, int unitTypeID )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetActionType( long queryID, int actionTypeID )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetState( long queryID, int state )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetPosition( long queryID, vector v )\par
\pard\fi720 Sets query data.\tab\par
\pard\par
bool kbUnitQuerySetMaximumDistance( long queryID, float distance )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetAscendingSort( long queryID, bool v )\par
\pard\fi720 If parm is true, results are sorted in ascending distance order from the \par
query position.\par
\par
\pard bool kbUnitQuerySetBaseID( long queryID, int baseID )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetAreaID( long queryID, int areaID )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetAreaGroupID( long queryID, int areaGroupID )\par
\pard\fi720 Sets query data.\par
\par
\pard bool kbUnitQuerySetArmyID( long queryID, int armyID )\par
Sets query data.\tab\par
\par
bool kbUnitQuerySetSeeableOnly( long queryID, bool seeableOnly )\par
\pard\fi720 Sets query data.\par
\par
\pard int kbUnitQueryExecute( long queryID )\par
\pard\fi720 Executes the current query; returns number of results.\par
\par
\pard int kbUnitQueryExecuteOnQuery( long currentQueryID, int previousQueryID )\par
\pard\fi720 Executes the current query on the previous query's results; returns the new \par
number of results.\par
\par
\pard int kbUnitQueryExecuteOnQueryByName( long currentQueryID, string previousQueryName )\par
\pard\fi720 Executes the current query on the previous query's results; returns the new \par
number of results.\par
\par
\pard int kbUnitGetPlanID( int unitID )\tab\par
\pard\fi720 Returns the plan ID for this unit ID.\par
\par
\pard int kbUnitGetBaseID( int unitID )\tab\par
\pard\fi720 Returns the base ID for this unit ID.\par
\par
\pard int kbUnitGetAreaID( int unitID )\par
\pard\fi720 Returns the area ID for this unit ID.\par
\par
\pard int kbUnitGetArmyID( int unitID )\par
\pard\fi720 Returns the army ID for this unit ID.\par
\par
\pard int kbUnitGetMovementType( int unitTypeID )\tab\par
\pard\fi720 Returns the movementType for this unitTypeID.\par
\par
\pard float kbUnitGetCurrentHitpoints( int unitID )\par
\pard\fi720 Returns the current hitpoints for this unit ID.\par
\par
\pard float kbUnitGetMaximumHitpoints( int unitID )\par
\pard\fi720 Returns the maximum hitpoints for this unit ID.\par
\par
\pard float kbUnitGetHealth( int unitID )\par
\pard\fi720 Returns the health for this unit ID.\par
\par
\pard float kbUnitGetCurrentAICost( int unitID )\par
\pard\fi720 Returns the current AI cost (worth) for this unit ID.\par
\par
\pard float kbUnitGetMaximumAICost( int unitID )\par
\pard\fi720 Returns the maximum AI cost (worth) for this unit ID.\par
\par
\pard vector kbUnitGetPosition( int unitID )\par
\pard\fi720 Returns the position for this unit ID.\par
\par
\pard bool kbUnitIsType( int unitID, long unitTypeID )\par
\pard\fi720 Returns true if the unit is of the unitTypeID.\par
\par
\pard int kbUnitGetActionType( int unitID )\par
\pard\fi720 Returns the actionTypeID of the unit.\par
\pard\par
int kbUnitGetTargetUnitID( int unitID )\par
\pard\fi720 Returns the target unit ID of the given unit.\par
\par
\pard int kbUnitGetNumberWorkers( int unitID )\par
\pard\fi720 Returns the number of units currently working on the given unit.\par
\par
\pard int kbUnitGetWorkerID( int unitID, int index )\par
\pard\fi720 Returns the index-th worker unit ID.\tab\par
\pard\par
int kbGetBuildLimit(int player, int unitTypeID )\par
\pard\fi720 Returns the number of the unit type you are allowed to have (ONLY WORKS ON BASE \par
UNIT TYPES); returns -1 if there is no limit.\par
\par
\pard int kbGetPopCapAddition(int player, int unitTypeID )\par
\pard\fi720 Returns amount of pop cap addition provided by the given unit type (ONLY WORKS ON \par
BASE UNIT TYPES).\par
\par
\pard int kbGetPopSlots(int player, int unitTypeID )\par
\pard\fi720 Returns the number of pop slots this unit takes (ONLY WORKS ON BASE UNIT TYPES).\par
\par
\pard int kbGetPopulationSlotsByUnitTypeID( int playerID, int unitTypeID )\par
\pard\fi720 Returns the number of pop slots currently occupied by this unit type.\par
\par
\pard int kbGetPopulationSlotsByQueryID( int queryID )\par
\pard\fi720 Returns the number of pop slots currently occupied by the results in the \par
given query.\par
\par
\pard int kbUnitCount(int player, int unitTypeID, int stateID )\par
\pard\fi720 Returns a quick unit count of units for a player.\par
\par
\pard void kbUnitCountConsole(int playerID1, int playerID2, string unitType, string state(s) )\par
\pard\fi720 Returns a quick unit count of player2's units from player1's perspective.\par
\par
\pard vector kbGetMapCenter( void )\par
\pard\fi720 Returns the center vector of the map.\par
\par
\pard float kbGetMapXSize( void )\par
\pard\fi720 Returns the X size of the map.\tab\par
\pard\par
float kbGetMapZSize( void )\par
\pard\fi720 Returns the Z size of the map.\par
\par
\pard void kbAreaCalculate()\par
\pard\fi720 Creates areas and area groups. DO THIS BEFORE ANYTHING ELSE IN YOUR SCRIPT.\par
\par
\pard int kbAreaGetNumber( void )\par
\pard\fi720 Returns the number of areas.\par
\par
\pard string kbAreaGetName( int areaID )\par
\pard\fi720 Returns the name of the given area.\par
\par
\pard bool kbAreaSetName( int areaID, string areaName )\par
\pard\fi720 Sets the name of the given area.\par
\par
\pard int kbAreaGetIDByPosition( vector position )\par
\pard\fi720 Returns the ID of the given area.\par
\par
\pard int kbAreaGroupGetIDByPosition( vector position )\par
\pard\fi720 Returns the ID of the given area group.\par
\par
\pard vector kbAreaGetCenter( int areaID )\par
\pard\fi720 Returns the center of the given area.\par
\par
\pard int kbAreaGetNumberTiles( int areaID )\par
\pard\fi720 Returns the number of tiles in the given area.\par
\par
\pard int kbAreaGetNumberBlackTiles( int areaID )\par
\pard\fi720 Returns the number of black tiles in the given area.\par
\par
\pard int kbAreaGetNumberVisibleTiles( int areaID )\par
\pard\fi720 Returns the number of visible tiles in the given area.\par
\par
\pard int kbAreaGetNumberFogTiles( int areaID )\par
\pard\fi720 Returns the number of fog tiles in the given area.\par
\par
\pard int kbAreaGetVisibilityChangeTime( int areaID )\par
\pard\fi720 Returns the gametime of the last visibility change for the given area.\par
\par
\pard int kbAreaGetNumberUnits( int areaID )\par
\pard\fi720 Returns the number of units in the given area.\par
\par
\pard int kbAreaGetUnitID( int areaID, long index )\par
\pard\fi720 Returns the Unit ID of the index-th unit in the given area.\par
\par
\pard int kbAreaGetNumberBorderAreas( int areaID )\par
\pard\fi720 Returns the number of border areas for the given area.\par
\par
\pard int kbAreaGetBorderAreaID( int areaID, long index )\par
\pard\fi720 Returns the Area ID of the index-th border area in the given area.\par
\par
\pard int kbAreaGetType( int areaID )\par
\pard\fi720 Returns the Type of area.\par
\par
\pard int kbAreaFindBestGatherAreaID( int unitTypeID )\par
\pard\fi720 Returns the Area ID of the best area to gather the given unit type.\par
\par
\pard int kbAreaGetClosetArea( vector position, int areaType, int areaType1, \par
\pard\fi720\li1440    float minDistance )\par
\pard\fi720 Returns the Area ID of the closest area, of the given types, to given postion.\par
\par
\pard int kbPathCreate( string name )\par
\pard\fi720 Creates a path with the given name.\par
\par
\pard bool kbPathDestroy( int pathID )\par
\pard\fi720 Destroys the given path.\par
\par
\pard int kbPathGetNumber( void )\par
\pard\fi720 Returns the number of paths.\par
\par
\pard int kbPathGetIDByIndex( long index )\par
\pard\fi720 Returns the index-th path ID.\par
\par
\pard string kbPathGetName( int pathID )\tab\par
\pard\fi720 Returns the name of the given path.\par
\par
\pard float kbPathGetLength( int pathID )\par
\pard\fi720 Returns the length of the given path.\par
\par
\pard int kbPathGetNumberWaypoints( int pathID )\par
\pard\fi720 Returns the number of waypoints in the given path.\par
\par
\pard bool kbPathAddWaypoint( int pathID, vector waypoint )\par
\pard\fi720 Adds the waypoint to the given path.\tab\par
\par
\pard vector kbPathGetWaypoint( int pathID, long waypointNumber )\par
\pard\fi720 Returns the appropriate waypoint from the given path.\par
\par
\pard bool kbCanSimPath( vector pointA, vector pointB, long protoUnitTypeID, float range )\par
\pard\fi720 Returns true if the given unit type can path from pointA to pointB.\par
\par
\pard bool kbCanPath2( vector pointA, vector pointB, long protoUnitTypeID, float range )\par
\pard\fi720 Returns true if the given unit type can path from pointA to pointB.\par
\par
\pard int kbCreateAttackRoute( string name, int startAreaID, int goalAreaID, \par
\pard\fi720\li1440    int numInitialRoutes)\par
\pard\fi720 Returns the Route ID if successful.\par
\par
\pard int kbCreateAttackRouteWithPath( string name, vector startPt, vector endPt)\par
\pard\fi720 Returns the Route ID if successful.\par
\par
\pard bool kbDestroyAttackRoute( int routeID )\par
\pard\fi720 Returns true if the route was deleted.\par
\par
\pard bool kbAddAttackRouteSector( int sector )\par
\pard\fi720 add a new sector to path to.\par
\par
\pard bool kbAddAttackRouteIgnoreID( int ignoreAreaID )\par
\pard\fi720 ignore this area when finding the route.\par
\par
\pard bool kbAddAttackRouteIgnoreType( int ignoreAreaTypeID )\par
\pard\fi720 ignore this areatype when finding the route.\par
\par
\pard bool kbAttackRouteAddPath( int attackRouteID, int pathID)\par
\pard\fi720 Rreturns true if path was added to attack route.\par
\par
\pard bool kbMakeAttackRoutes()\par
\pard\fi720 find all the paths to the sector specified.\tab\par
\pard\par
int kbGetNumAttackRoutes( long startAreaID, long goalAreaID)\par
\pard\fi720 Returns num paths from start to goal area.\par
\par
\pard int kbGetAttackRouteID( long startAreaID, long goalAreaID)\par
\pard\fi720 Returns the id of the routes from area1 to area2.\par
\par
\pard int kbEscrowCreate( string name, int resourceID, float percentage, int parentID )\par
\pard\fi720 Creates an escrow.\par
\par
\pard bool kbEscrowDestroy( int escrowID, bool promoteChildren )\par
\pard\fi720 Destroys an escrow.\par
\par
\pard int kbEscrowGetID( string name )\par
\pard\fi720 Returns the ID of the named escrow.\par
\par
\pard float kbEscrowGetPercentage( int escrowID, int resourceID )\par
\pard\fi720 Returns the percentage of the escrow.\par
\par
\pard bool kbEscrowSetPercentage( int escrowID, int resourceID, float percentage )\par
\pard\fi720 Sets the percentage of the escrow.\par
\par
\pard bool kbEscrowSetCap( int escrowID, int resourceID, float cap )\par
\pard\fi720 Sets the cap of the escrow.\par
\par
\pard float kbEscrowGetAmount( int escrowID, int resourceID )\par
\pard\fi720 Returns the amount of credits in the given escrow for the given resource.\par
\par
\pard bool kbEscrowFlush( int escrowID, int resourceID, bool flushChildren )\par
\pard\fi720 Removes all credits (and puts them into the root escrow) of the given resource \par
type from the given escrow.\par
\par
\pard bool kbEscrowAllocateCurrentResources( void )\par
\pard\fi720 Reallocates the current resource stockpile into the escrows.\par
\par
\pard int kbBuildingPlacementCreate( string name )\par
\pard\fi720 Creates a building placement; returns the ID.\par
\par
\pard bool kbBuildingPlacementDestroy( int id )\par
\pard\fi720 Destroys the given building placement.\par
\par
\pard bool kbBuildingPlacementResetResults( void )\par
\pard\fi720 Resets the current building placement.\par
\par
\pard bool kbBuildingPlacementSelect( int id )\par
\tab Selects the given building placement.\par
\par
bool kbBuildingPlacementSetEventHandler( int eventType, string handlerName )\par
\tab Sets event handler function for the current BP and event.\par
\par
bool kbBuildingPlacementSetBuildingType( int buildingTypeID )\par
\tab Sets the building type for the current building placement.\par
\par
bool kbBuildingPlacementSetBaseID( int baseID, int locationPref )\par
\tab Sets the base ID and location preference for the current building placement.\par
\par
bool kbBuildingPlacementAddAreaID( int areaID, int numberBorderAreaLayers, \par
\pard\fi720\li2160      bool addCenterInfluence )\par
\pard\tab Adds the Area ID to the current BP (with the given number of border area layers), \par
\pard\fi720 addCenterInfluence - adds a positional influence from the area center.\par
\par
\pard bool kbBuildingPlacementAddAreaGroupID( int areaGroupID )\par
\tab Adds the AreaGroup ID to the current BP.\par
\par
bool kbBuildingPlacementSetCenterPosition( vector position, float distance, float obstructionRadius )\par
\tab Sets up center position-based BP.\par
\par
bool kbBuildingPlacementAddUnitInfluence( int typeID, float value, float distance, \par
\pard\fi720\li2880      long kbResourceID )\par
\pard\tab Adds the unit influence for the current building placement.\par
\par
bool kbBuildingPlacementAddPositionInfluence( vector position, float value, \par
\pard\fi720\li3600  float distance )\par
\pard\tab Adds the position influence for the current building placement.\par
\par
bool kbBuildingPlacementSetMinimumValue( float minimumValue )\par
\tab Sets the minimum acceptable value for evaluated spots in the BP.\par
\par
bool kbBuildingPlacementStart( void )\par
\tab Starts the placement of current building.\par
\par
vector kbBuildingPlacementGetResultPosition( int bpID )\par
\tab Returns the vector result position for given BP ID.\par
\par
float kbBuildingPlacementGetResultValue( int bpID )\par
\tab Returns the result value for given BP ID.\par
\par
int kbTargetSelectorCreate( string name )\par
\tab Creates a target selector; returns the ID.\par
\par
bool kbTargetSelectorDestroy( int id )\par
\tab Destroys the given target selector.\par
\par
bool kbTargetSelectorResetResults( void )\par
\tab Resets the current target selector.\par
\par
bool kbTargetSelectorSelect( int id )\par
\tab Selects the given target selector.\par
\par
bool kbTargetSelectorAddUnitType( int protoUnitTypeID )\par
\tab Add the UAIT for the given BASE unit type as a filter.\par
\par
bool kbTargetSelectorAddQueryResults( int queryID )\par
\tab Sets the list of potential targets to the results in the given query.\par
\par
int kbTargetSelectorGetNumberResults( void )\par
\tab Returns the number of results in the given target selector.\par
\par
int kbTargetSelectorGetResultValue( int index )\par
\tab Returns the result value for given index of the current target selector.\par
\par
bool kbTargetSelectorStart( void )\par
\tab Starts the current target selector.\par
\par
bool kbSetupForResource( int baseID, int resourceID, float distance, float amount )\par
\tab Returns true if amount of resource is within distance of a dropsite.\par
\par
float kbResourceGet( int resourceID )\par
\tab Returns the current amount of the given resource.\par
\par
float kbMaximumResourceGet( int resourceID )\par
\tab Returns the maximum amount of the given resource you can have.\par
\par
float kbTotalResourceGet( int resourceID )\par
\tab Returns the total amount of the given resource gathered to this point in the game.\par
\par
int kbGetNumberValidResourcesByPlan( int planID, int baseID )\par
\tab Returns the number of valid KB resources for the given plan/base.\par
\par
int kbGetNumberValidResources( int baseID, int resourceTypeID, int resourceSubTypeID,\par
\pard\fi720\li2160  float distance )\par
\pard\tab Returns the number of valid KB resources for the resource types.\par
\par
float kbGetAmountValidResources( int baseID, int resourceTypeID, int resourceSubTypeID,\par
\pard\fi720\li2160    float distance  )\par
\pard\tab Returns the resource amount of valid KB resources for the resource types.\par
\par
float kbGetResourceIncome( int resourceID, float seconds, bool relative )\par
\tab Returns the resource income over the last X seconds.\par
\par
bool kbProtoUnitAvailable( int protoUnitID )\par
\tab Returns true if the protoUnit is currently available.\par
\par
int kbGetProtoUnitID( string name )\par
\tab Returns the ID of the protounit.\par
\par
bool kbCanAffordUnit( int protoUnitTypeID, int escrowID )\par
\tab Returns true if the player can afford the proto unit.\par
\par
bool kbCanAffordTech( int techID, int escrowID )\par
\tab Returns true if the player can afford the tech.\par
\par
int kbGetTechStatus( int techID )\par
\tab Returns the current tech status for the current player of the requested tech.\par
\par
float kbGetTechPercentComplete( int techID )\par
\tab Returns the percent complete for the the requested tech of the current player.\par
\par
float kbGetCombatEfficiency( int playerID1, int unitTypeID1, int playerID2, \par
\pard\fi720\li2160 int unitTypeID2 )\par
\pard\tab Returns the combat efficiency of the comparison (in terms of playerID1's units).\par
\par
float kbGetAICostWeight( int resourceID )\par
\tab Returns the AI cost weight for the given resource.\par
\par
bool kbSetAICostWeight( int resourceID, float weight )\par
\tab Sets the weight this resource type is given during AI cost calculuations.\par
\par
float kbGetProtoUnitAICost( int protoUnitTypeID )\par
\tab Returns the AI cost for the given protoUnit type ID.\par
\par
float kbGetTechAICost( int techID )\par
\tab Returns the AI cost for the given tech ID.\par
\par
bool kbIsPlayerResigned( <playerID> )\par
\tab Returns the player's resigned status.\par
\par
bool kbHasPlayerLost( <playerID> )\par
\tab Returns the player's lost status.\par
\par
int kbGetPlayerTeam( <playerID> )\par
\tab Returns the player's team number.\par
\par
bool kbIsPlayerEnemy( int playerID )\par
\tab Returns true if the given player is an enemy.\par
\par
bool kbIsPlayerNeutral( int playerID )\par
\tab Returns true if the given player is a neutral player.\par
\par
bool kbIsPlayerAlly( int playerID )\par
\tab Returns true if the given player is an ally.\par
\par
bool kbIsPlayerValid( int playerID )\par
\tab Returns true if the given player is a valid player (i.e. it exists in the game).\par
\par
bool kbIsPlayerHuman( int playerID )\par
\tab Returns true if the given player is a a human player.\par
\par
bool kbIsGameOver()\par
\tab Returns whether the game is over or not.\par
\par
vector kbGetTownLocation( void )\par
\tab Returns the location of the main town.\par
\par
int kbGetTownAreaID( void )\par
\tab Returns the area ID of the main town.\par
\par
bool kbSetTownLocation( vector location )\par
\tab Sets the location of the main town.\par
\par
bool kbGetAutoBaseCreate( void )\par
\tab Returns the auto base creation value.\par
\par
void kbSetAutoBaseCreate( bool v )\par
\tab Sets the auto base creation value.\par
\par
float kbGetAutoBaseCreate( void )\par
\tab Returns the auto base creation distance.\par
\par
void kbSetAutoBaseCreateDistance( float v )\par
\tab Sets the auto base creation distance.\par
\par
bool kbGetAutoBaseDetect( void )\par
\tab Returns the auto base detection value.\par
\par
void kbSetAutoBaseDetect( bool v )\par
\tab Sets the auto base detection value.\par
\par
float kbGetAutoBaseDetect( void )\par
\tab Returns the auto base creation distance.\par
\par
void kbSetAutoBaseDetectDistance( float v )\par
\pard\fi720 Sets the auto base creation distance.\par
\par
\pard int kbBaseGetNextID( void )\par
\pard\fi720 Returns the ID of the next base that will be created.\par
\par
\pard int kbBaseGetNumber( int playerID )\par
\pard\fi720 Returns the number of bases for the given player.\par
\par
\pard int kbBaseGetIDByIndex( int playerID, int index )\par
\pard\fi720 Returns the BaseID for the given base.\par
\par
\pard int kbBaseCreate( int playerID, string name, vector position, float distance )\par
\pard\fi720 Creates a base.\par
\par
\pard int kbBaseFindCreateResourceBase( int resourceType, int resourceSubType, \par
\pard\li2880     int parentBaseID )\par
\pard\fi720 Finds/Creates a resource base.\par
\par
\pard int kbBaseFindCreateResourceBase( int enemyPlayerID, int enemyBaseID )\par
\pard\fi720 Finds/Creates a 'forward' military base against the given enemy base.\par
\par
\pard bool kbBaseDestroy( int playerID, int baseID )\par
\pard\fi720 Destroys the given base.\par
\par
\pard void kbBaseDestroyAll( int playerID )\par
\pard\fi720 Destroys all of the bases for the given player.\par
\par
\pard vector kbBaseGetLocation( int playerID, int baseID )\par
\pard\fi720 Gets the location of the base.\par
\par
\pard bool kbBaseSetFrontVector( int playerID, int baseID, vector frontVector )\par
\pard\fi720 Sets the front (and back) of the base.\par
\par
\pard vector kbBaseGetFrontVector( int playerID, int baseID )\par
\pard\fi720 Gets the front vector of the base.\par
\par
\pard vector kbBaseGetBackVector( int playerID, int baseID )\par
\pard\fi720 Gets the back vector of the base.\par
\par
\pard int kbBaseGetTimeUnderAttack( int playerID, int baseID )\par
\pard\fi720 Returns the number of continuous seconds the base has been under attack.\par
\par
\pard bool kbBaseGetUnderAttack( int playerID, int baseID )\par
\pard\fi720 Gets the under attack flag of the base.\par
\par
\pard bool kbBaseSetActive( int playerID, int baseID, bool active )\par
\pard\fi720 Sets the active flag of the base.\par
\par
\pard bool kbBaseGetActive( int playerID, int baseID )\par
\pard\fi720 Gets the active flag of the base.\par
\par
\pard int kbBaseGetMainID( int playerID )\par
\pard\fi720 Gets the main base ID for the player.\par
\par
\pard bool kbBaseSetMain( int playerID, int baseID, bool main )\par
\pard\fi720 Sets the main flag of the base.\par
\par
\pard bool kbBaseGetMain( int playerID, int baseID )\par
\pard\fi720 Gets the main flag of the base.\par
\par
\pard bool kbBaseSetForward( int playerID, int baseID, bool forward )\par
\pard\fi720 Sets the forward flag of the base.\par
\par
\pard bool kbBaseGetForward( int playerID, int baseID )\par
\pard\fi720 Gets the forward flag of the base.\par
\par
\pard bool kbBaseSetSettlement( int playerID, int baseID, bool settlement )\par
\pard\fi720 Sets the settlement flag of the base.\tab\par
\pard\par
bool kbBaseGetSettlement( int playerID, int baseID )\par
\pard\fi720 Gets the settlement flag of the base.\par
\par
\pard bool kbBaseSetMilitary( int playerID, int baseID, bool military )\par
\pard\fi720 Sets the military flag of the base.\par
\par
\pard bool kbBaseGetMilitary( int playerID, int baseID )\par
\pard\fi720 Gets the military flag of the base.\tab\par
\pard\par
vector kbBaseGetMilitaryGatherPoint( int playerID, int baseID )\par
\pard\fi720 Gets the military gather point of the base.\par
\par
\pard bool kbBaseSetMilitaryGatherPoint( int playerID, int baseID, vector gatherPoint )\par
\pard\fi720 Sets the military gather point of the base.\par
\par
\pard bool kbBaseSetEconomy( int playerID, int baseID, bool Economy )\par
\pard\fi720 Sets the economy flag of the base.\par
\par
\pard bool kbBaseGetEconomy( int playerID, int baseID )\par
\pard\fi720 Gets the economy flag of the base.\par
\par
\pard float kbBaseGetMaximumResourceDistance( int playerID, int baseID )\par
\pard\fi720 Gets the maximum resource distance of the base.\par
\par
\pard void kbBaseSetMaximumResourceDistance( int playerID, int baseID, float distance )\par
\pard\fi720 Sets the maximum resource distance of the base.\par
\par
\pard bool kbBaseAddUnit( int playerID, int baseID, int unitID )\par
\pard\fi720 Adds the given unit to the base.\par
\par
\pard bool kbBaseRemoveUnit( int playerID, int baseID, int unitID )\par
\pard\fi720 Removes the given unit to the base.\par
\par
\pard int kbBaseGetNumberUnits( int playerID, int baseID, int relation, int unitTypeID )\par
\pard\fi720 Returns the number of units that match the criteria.\par
\par
\pard bool kbUnitVisible( int unitID )\par
\pard\fi720 Returns true if the unit is currently visible to the player.\par
\par
\pard bool kbLocationVisible( vector location )\par
\pard\fi720 Returns true if the location is currently visible to the player.\par
\par
\pard vector kbGetBlockPosition( string blockName )\par
\pard\fi720 Returns the position of the cinematic block.\par
\par
\pard int kbGetBlockID( string blockName )\par
\pard\fi720 Returns the UnitID of the cinematic block.\par
\par
\pard int kbUnitPickCreate( string name )\par
\pard\fi720 Creates a unit pick.\par
\par
\pard bool kbUnitPickDestroy( int upID )\par
\pard\fi720 Destroys the given unit pick.\par
\par
\pard bool kbUnitPickResetAll( int upID )\par
\pard\fi720 Resets all of the unit pick data.\par
\par
\pard bool kbUnitPickResetResults( int upID )\par
\pard\fi720 Resets the unit pick results.\par
\par
\pard bool kbUnitPickSetPreferenceWeight( int upID )\par
\pard\fi720 Sets the unit pick preference weight.\par
\par
\pard bool kbUnitPickSetEnemyPlayerID( int upID )\par
\pard\fi720 Sets the unit pick enemy player ID.\par
\par
\pard bool kbUnitPickSetCombatEfficiencyWeight( int upID )\par
\pard\fi720 Sets the unit pick combat efficiency weight.\par
\par
\pard bool kbUnitPickResetCombatEfficiencyTypes( int upID )\par
\pard\fi720 Resets the enemy unit typeIDs for the unit pick combat efficiency calculation.\par
\par
\pard bool kbUnitPickAddCombatEfficiencyType( int upID, int typeID, float weight )\par
\pard\fi720 Adds an enemy unit typeID to the unit pick combat efficiency calculation.\par
\par
\pard bool kbUnitPickSetCostWeight( int upID )\par
\pard\fi720 Sets the unit pick cost weight.\par
\par
\pard bool kbUnitPickSetMovementType( int upID, int movementType )\par
\pard\fi720 Sets the unit pick movement type.\par
\par
\pard bool kbUnitPickSetDesiredNumberUnitTypes( int upID, int number, int numberBuildings, \par
\pard\fi720\li2880      bool degradeNumberBuildings )\par
\pard\fi720 Sets the unit pick desired number unit types.\par
\par
\pard int kbUnitPickGetDesiredNumberUnitTypes( int upID )\par
\pard\fi720 Gets the unit pick desired number unit types.\par
\par
\pard bool kbUnitPickSetDesiredNumberBuildings( int upID, int index, int numberBuildings )\par
\pard\fi720 Sets the unit pick desired number buildings for the index-th unit type.\par
\par
\pard int kbUnitPickGetDesiredNumberBuildings( int upID, int index )\par
\pard\fi720 gets the unit pick desired number buildings for the index-th unit type.\par
\par
\pard bool kbUnitPickSetMinimumNumberUnits( int upID, int number )\par
\pard\fi720 Sets the unit pick desired number unit types.\par
\par
\pard int kbUnitPickGetMinimumNumberUnits( int upID )\par
\pard\fi720 Gets the unit pick minimum number units.\par
\par
\pard bool kbUnitPickSetMaximumNumberUnits( int upID, int number )\par
\pard\fi720 Sets the unit pick desired number unit types.\par
\par
\pard int kbUnitPickGetMaximumNumberUnits( int upID )\par
\pard\fi720 Gets the unit pick maximum number units.\par
\par
\pard bool kbUnitPickSetMinimumPop( int upID, int number )\par
\pard\fi720 Sets the unit pick desired min pop.\par
\par
\pard int kbUnitPickGetMinimumPop( int upID )\par
\pard\fi720 Gets the unit pick minimum pop.\par
\par
\pard bool kbUnitPickSetMaximumPop( int upID, int number )\par
\pard\fi720 Sets the unit pick desired max pop.\par
\par
\pard int kbUnitPickGetMaximumPop( int upID )\par
\pard\fi720 Gets the unit pick maximum pop.\par
\par
\pard bool kbUnitPickSetAttackUnitType( int upID, int type )\par
\pard\fi720 Sets the unit pick attack unit type.\par
\par
\pard int kbUnitPickGetAttackUnitType( int upID )\par
\pard\fi720 Gets the unit pick attack unit type.\par
\par
\pard bool kbUnitPickSetPreferenceFactor( int upID, int unitTypeID, float preferenceFactor ) \par
\pard\fi720 Sets the preferenceFactor for that unit type.\par
\par
\pard bool kbUnitPickAdjustPreferenceFactor( int upID, int unitTypeID, \par
\pard\fi720\li2880   float baseFactorAdjustment )\tab\par
\pard\fi720 Adjusts the preferenceFactor for that unit type (uses 50.0 as the base if the UP \par
doesn't exist yet).\par
\par
\pard int kbUnitPickRun( int upID )\par
\pard\fi720 Runs the unit pick.\par
\par
\pard int kbUnitPickGetNumberResults( int upID )\par
\pard\fi720 Returns the number of unit pick results.\par
\par
\pard int kbUnitPickGetResult( int upID, int index )\par
\pard\fi720 Returns the index-th ProtoUnitID.\par
\par
\pard int kbFindAreaGroup( int groupType, float surfaceAreaRatio, int compareAreaID)\par
\pard\fi720 returns the area group that matches the given criteria.\par
\par
\pard int kbFindBestBuildingToRepair(vector position, float distance, float healthRatio, \par
\pard\fi720\li2160  int repairUnderAttackUnitTypeID)\par
\pard\fi720 returns the id of the best building to repair.\par
\par
\pard void kbSetForwardBasePosition(vector position)\par
\pard\fi720 set the explicit position that every forward base will use.\par
\par
\pard int kbArmyCreate( string name, bool exclusiveUnits )\par
\pard\fi720 Creates a army with the given name.\par
\par
\pard bool kbArmyDestroy( integer id )\par
\pard\fi720 Destroys the given army.\par
\par
\pard int kbArmyGetNumber( void )\par
\pard\fi720 Returns the number of armies.\par
\par
\pard int kbArmyGetID( string name )\par
\pard\fi720 Returns the ID of the given army.\par
\par
\pard int kbArmyGetIDByIndex( long index )\par
\pard\fi720 Returns the index-th army ID.\tab\par
\pard\par
string kbArmyGetName( integer id )\par
\pard\fi720 Returns the name of the given army.\par
\par
\pard int kbArmyGetNumberUnits( integer armyID )\par
\pard\fi720 Returns the number of units in the given army.\par
\par
\pard int kbArmyGetUnitID( integer armyID, long unitNumber )\par
\pard\fi720 Returns the appropriate unitID from the given army.\par
\par
\pard bool kbArmyAddUnit( integer armyID, integer unitID )\par
\pard\fi720 Adds the unitID to the given army.\par
\par
\pard bool kbArmyRemoveUnit( integer armyID, integer unitID )\par
\pard\fi720 Removes the unitID from the given army.\par
\par
\pard bool kbArmyRemoveUnitByIndex( integer armyID, integer unitIndex )\par
\pard\fi720 Removes the unitIndex-th unit from the given army.\tab\par
\pard\par
bool kbArmyRemoveUnits( integer armyID )\par
\pard\fi720 Removes all units from the given army.\par
\par
\pard int kbArmyGetPlanID( integer armyID )\par
\pard\fi720 Returns the planID for the given army.\par
\par
\pard int kbArmyGetCreationTime( integer armyID )\par
\pard\fi720 Returns the creation time for the given army.\par
\par
\pard int kbArmyGetMembershipTime( integer armyID )\par
\pard\fi720 Returns the creation time for the given army.\par
\par
\pard vector kbArmyGetLocation( integer armyID )\par
\pard\fi720 Returns the vector location for the given army.\par
\par
\pard int kbArmyGetNumberWithinLocation( integer armyID, vector point, float range )\par
\pard\fi720 Returns the number of units within range of the given point in the given army.\par
\par
\pard float kbArmyGetCurrentHitpoints( integer armyID )\par
\pard\fi720 Returns the current total hitpoints for the given army.\par
\par
\pard float kbArmyGetMaximumHitpoints( integer armyID )\par
\pard\fi720 Returns the maximum total hitpoints for the given army.\par
\par
\pard float kbArmyGetHealth( integer armyID )\par
\pard\fi720 Returns the health for the given army.\par
\par
\pard int kbArmyGetNumberWithHealth( integer armyID, float minimumHealth )\par
\pard\fi720 Returns the number of units with at least the minimum amount of health specified \par
for the given army.\par
\par
\pard float kbArmyGetCurrentAICost( integer armyID )\par
\pard\fi720 Returns the current AI cost (worth) for the given army.\par
\par
\pard float kbArmyGetMaximumAICost( integer armyID )\par
\pard\fi720 Returns the maximum AI cost (worth) for the given army.\par
\par
\pard float kbArmyGetAPSDamageTaken( integer armyID, float timeSpan )\par
\pard\fi720 Returns the APS damage taken by the given army.\par
\pard\par
float kbArmyGetAPSDamageGiven( integer armyID, float timeSpan )\par
\pard\fi720 Returns the APS damage given by the given army.\par
\pard\par
float kbArmyGetAPSResourcesGathered( integer armyID, float timeSpan, integer resourceID )\par
\pard\fi720 Returns the APS resources gathered by the given army.\par
\par
\pard void kbForceContextPlayerID()\par
\pard\fi720 use for debugging or manual scenario repair ONLY!!!\par
\par
\pard int kbTechTreeGetNumberMatrixUnitTypeIDs( void )\par
\pard\fi720 Returns the number of matrix unit type IDs.\par
\pard\par
int kbTechTreeGetMatrixUnitTypeIDByIndex( int index )\par
\pard\fi720 Returns the matrix unit typeID at the given index.\par
\pard\par
int kbTechTreeGetTotalUnitIDsByMatrix(int mainUnitTypeID, int counterUnitTypeID)\par
\pard\fi720 Returns the total number of unitIDs matching the main type that \par
has the given counter type.\par
\pard\par
int kbTechTreeGetUnitIDByMatrixIndex(int mainUnitTypeID, int counterUnitTypeID, \par
                                     int index)\par
\pard\fi720 Returns the index'th unitID matching the main type that has \par
the given counter type.\par
\pard\par
int kbTechTreeGetTotalUnitIDsByFunction( int functionID )\par
\pard\fi720 Returns the total number of unitIDs that performs the given function.\par
\pard\par
int kbTechTreeGetUnitIDTypeByFunctionIndex( int functionID, int index )\par
\pard\fi720 Returns the index'th unitID of the unit that performs the given function.\par
\pard\par
int kbTechTreeGetNumberDropsiteUnitIDsByResource( int resourceID )\par
\pard\fi720 Returns the number of unit typeIDs for dropsites that take the given resource.\par
\pard\par
bool kbTechTreeClearDropsiteUnitIDsByResource( int resourceID )\par
\pard\fi720 Clears the list of dropsites for the given resource type.\par
\pard\par
bool kbTechTreeAddDropsiteUnitIDByResource( int resourceID )\par
\pard\fi720 Adds the base unit type ID as a dropsite for the given resource.\par
\pard\par
int kbTechTreeGetDropsiteUnitIDByResource( int resourceID, int index )\par
\pard\fi720 Returns the index-th unitID of the dropsite that takes the given resource.\par
\pard\par
int kbTechTreeGetUnitIDByTrain( int unitTypeID, int civID )\par
\pard\fi720 Returns the unitTypeID of the unit that can train the given unitTypeID.\par
\pard\par
int kbTechTreeGetNumberTrainProtos( int unitTypeID )\par
\pard\fi720 Returns the number of protos that can train the given unitTypeID.\par
\pard\par
int kbTechTreeGetUnitIDByTrainIndex( int unitTypeID, int trainProtoIndex )\par
\pard\fi720 Returns index'th unitTypeID of the unit that can train the given unitTypeID.\par
\pard\par
int kbTechTreeGetNumberObtainProtos( int techID )\par
\pard\fi720 Returns the number of protos that the given techID can be obtained from.\par
\pard\par
int kbTechTreeGetUnitIDByObtainIndex( int techID, int obtainProtoIndex )\par
\pard\fi720 Returns index'th unitTypeID of the unit that the given techID, \par
can be obtained from.\par
\pard\par
string kbGetTechName( int techID )\par
\pard\fi720 Returns the name of the tech ID.\par
\pard\par
string kbGetProtoUnitName( int protoUnitTypeID )\par
\pard\fi720 Returns the name of the protounit ID.\par
\pard\par
int kbGetUnitBaseTypeID( int unitID )\par
\pard\fi720 Returns the base type ID of the unit.\par
\pard\par
string kbGetUnitTypeName( int unitTypeID )\par
\pard\fi720 Returns the name of the unit type.\par
\pard\par
int kbTechTreeGetUnitUpgradeTechTotal( int unitTypeID )\par
\pard\fi720 Returns the total number of upgrade techs of the unit type.\par
\pard\par
int kbTechTreeGetUnitUpgradeTech( int unitTypeID, int index )\par
\pard\fi720 Returns the index'th upgrade techs of the unit type.\par
\pard\par
int kbTechTreeGetCheapestUnitUpgrade( int protoUnitID, int upgradeQueryType, \par
                                      int resourceFilterID, int buildingFilterID, \par
                                      bool echoResults, int affectedUnitType )\par
\tab Returns the Tech ID of the Cheapest Unit Upgrade, given the input parameters.\par
\par
int kbTechTreeGetRandomUnitUpgrade()\par
\par
bool kbTechTreeIsMinorGod( int techID ) \par
\pard\fi720 Returns true if techID is a minor god tech.\par
\pard\par
int kbTechTreeGetGPTechID( int minorGodTechID ) \par
\pard\fi720 Returns the GP techID that is enabled by minorGodTechID.\par
\pard\par
bool kbTechTreeAddMinorGodPref( int techID ) \par
\pard\fi720 Have progressions preference this minor god selection.\par
\pard\par
bool kbTechTreeRemoveMinorGodPref( int techID ) \par
\pard\fi720 Removes this minor god as perference in Progressions.\par
\pard\par
int kbTechTreeGetMinorGodMythUnitTotal( int minorGodTechID)\par
\pard\fi720 Returns the total number of myths units enabled by this minor god.\par
\pard\par
int kbTechTreeGetMinorGodMythUnitByIndex( int minorGodTechID, int index ) \par
\pard\fi720 Returns the protoID of a myth unit\par
\pard\par
int kbTechTreeGetMinorGodChoices( int index, int age )\par
\pard\fi720 Returns the minorGodTechID of the given index, given the age, -1 means \par
the next age.\par
\pard\par
int kbProgressionGetTotalNodes( int progressionID )\par
\pard\fi720 Returns the total number of steps to complete the progression.\par
\pard\par
float kbProgessionGetTotalResourceCost( int progressionID, int resourceID )\par
\pard\fi720 Returns the total cost of the given resource for this progressionID.\par
\pard\par
float kbProgessionGetTotalWorkCost( int progressionID )\par
\pard\fi720 Returns the total work cost this progressionID.\par
\pard\par
int kbProgressionGetNodeType( int progressionID, int nodeIndex )\par
\pard\fi720 Returns the type of node at the given index, either Unit type or Tech type.\par
\pard\par
int kbProgressionGetNodeData( int progressionID, int nodeIndex )\par
\pard\fi720 Returns the data at nodeIndex, either UnitID or TechID, depending on the type.\par
\pard\par
bool kbProgressionIsNodeMinorGod( int progressionID, int nodeIndex )\par
\tab Returns true if this nodeIndex is a Minor God Tech.\par
\pard\lang1033\f4\fs20\par
}
 